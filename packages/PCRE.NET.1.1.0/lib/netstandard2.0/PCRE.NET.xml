<?xml version="1.0"?>
<doc>
    <assembly>
        <name>PCRE.NET</name>
    </assembly>
    <members>
        <member name="T:PCRE.Conversion.PcreConvert">
            <summary>
            Pattern conversions.
            </summary>
        </member>
        <member name="M:PCRE.Conversion.PcreConvert.FromPosixBasic(System.String)">
            <summary>
            Converts a POSIX basic pattern to a PCRE pattern.
            </summary>
            <param name="pattern">The pattern to convert.</param>
        </member>
        <member name="M:PCRE.Conversion.PcreConvert.FromPosixExtended(System.String)">
            <summary>
            Converts a POSIX extended pattern to a PCRE pattern.
            </summary>
            <param name="pattern">The pattern to convert.</param>
        </member>
        <member name="M:PCRE.Conversion.PcreConvert.FromGlob(System.String,PCRE.Conversion.PcreGlobConversionOptions)">
            <summary>
            Converts a glob pattern to a PCRE pattern.
            </summary>
            <param name="pattern">The pattern to convert.</param>
            <param name="options">Conversion options.</param>
            <remarks>
            Globs are used to match file names, and consequently have the concept of a "path separator", which defaults to backslash under Windows and forward slash otherwise.
            The wildcards <c>*</c> and <c>?</c> are not permitted to match separator characters, but the double-star (<c>**</c>) feature (which does match separators) is supported.
            </remarks>
        </member>
        <member name="T:PCRE.Conversion.PcreGlobConversionOptions">
            <summary>
            Conversion options for glob patterns.
            </summary>
        </member>
        <member name="P:PCRE.Conversion.PcreGlobConversionOptions.NoWildcardSeparator">
            <summary>
            <c>PCRE2_CONVERT_GLOB_NO_WILD_SEPARATOR</c> - Allow wildcards to match separator characters.
            </summary>
        </member>
        <member name="P:PCRE.Conversion.PcreGlobConversionOptions.NoStarStar">
            <summary>
            <c>PCRE2_CONVERT_GLOB_NO_STARSTAR</c> - Disable the double-star (<c>**</c>) wildcard.
            </summary>
        </member>
        <member name="P:PCRE.Conversion.PcreGlobConversionOptions.EscapeCharacter">
            <summary>
            The escape character.
            </summary>
            <remarks>
            Defaults to <c>`</c> under Windows, and <c>\</c> otherwise.
            </remarks>
        </member>
        <member name="P:PCRE.Conversion.PcreGlobConversionOptions.SeparatorCharacter">
            <summary>
            The path separator character.
            </summary>
            <remarks>
            Defaults to <c>\</c> under Windows, and <c>/</c> otherwise.
            </remarks>
        </member>
        <member name="M:PCRE.Conversion.PcreGlobConversionOptions.DefaultWindows">
            <summary>
            Returns default options for Windows.
            </summary>
        </member>
        <member name="M:PCRE.Conversion.PcreGlobConversionOptions.DefaultUnix">
            <summary>
            Returns default options for Unix.
            </summary>
        </member>
        <member name="T:PCRE.Dfa.PcreDfaMatch">
            <summary>
            An output item of a DFA match.
            </summary>
        </member>
        <member name="P:PCRE.Dfa.PcreDfaMatch.Index">
            <inheritdoc cref="P:PCRE.PcreMatch.Index"/>
        </member>
        <member name="P:PCRE.Dfa.PcreDfaMatch.EndIndex">
            <inheritdoc cref="P:PCRE.PcreMatch.EndIndex"/>
        </member>
        <member name="P:PCRE.Dfa.PcreDfaMatch.Length">
            <inheritdoc cref="P:PCRE.PcreMatch.Length"/>
        </member>
        <member name="P:PCRE.Dfa.PcreDfaMatch.Value">
            <inheritdoc cref="P:PCRE.PcreMatch.Value"/>
        </member>
        <member name="P:PCRE.Dfa.PcreDfaMatch.ValueSpan">
            <inheritdoc cref="P:PCRE.PcreMatch.ValueSpan"/>
        </member>
        <member name="P:PCRE.Dfa.PcreDfaMatch.Success">
            <inheritdoc cref="P:PCRE.PcreMatch.Success"/>
        </member>
        <member name="M:PCRE.Dfa.PcreDfaMatch.op_Implicit(PCRE.Dfa.PcreDfaMatch)~System.String">
            <summary>
            Converts a match to its matched substring.
            </summary>
        </member>
        <member name="M:PCRE.Dfa.PcreDfaMatch.ToString">
            <inheritdoc cref="M:PCRE.PcreMatch.ToString"/>
        </member>
        <member name="T:PCRE.Dfa.PcreDfaMatchOptions">
            <summary>
            Options for DFA matching.
            </summary>
        </member>
        <member name="F:PCRE.Dfa.PcreDfaMatchOptions.None">
            <summary>
            No additional options.
            </summary>
        </member>
        <member name="F:PCRE.Dfa.PcreDfaMatchOptions.Anchored">
            <inheritdoc cref="F:PCRE.PcreMatchOptions.Anchored"/>
        </member>
        <member name="F:PCRE.Dfa.PcreDfaMatchOptions.EndAnchored">
            <inheritdoc cref="F:PCRE.PcreMatchOptions.EndAnchored"/>
        </member>
        <member name="F:PCRE.Dfa.PcreDfaMatchOptions.NotBol">
            <inheritdoc cref="F:PCRE.PcreMatchOptions.NotBol"/>
        </member>
        <member name="F:PCRE.Dfa.PcreDfaMatchOptions.NotEol">
            <inheritdoc cref="F:PCRE.PcreMatchOptions.NotEol"/>
        </member>
        <member name="F:PCRE.Dfa.PcreDfaMatchOptions.NotEmpty">
            <inheritdoc cref="F:PCRE.PcreMatchOptions.NotEmpty"/>
        </member>
        <member name="F:PCRE.Dfa.PcreDfaMatchOptions.NotEmptyAtStart">
            <inheritdoc cref="F:PCRE.PcreMatchOptions.NotEmptyAtStart"/>
        </member>
        <member name="F:PCRE.Dfa.PcreDfaMatchOptions.NoUtfCheck">
            <inheritdoc cref="F:PCRE.PcreMatchOptions.NoUtfCheck"/>
        </member>
        <member name="F:PCRE.Dfa.PcreDfaMatchOptions.PartialSoft">
            <summary>
            <c>PCRE2_PARTIAL_SOFT</c> - Enable partial matching mode. Still try to find a complete match if a partial match is found first.
            </summary>
            <remarks>
            <para>
            These have the same general effect as they do for <c>pcre2_match()</c>, but the details are slightly different.
            </para>
            <para>
            When <see cref="F:PCRE.Dfa.PcreDfaMatchOptions.PartialHard"/> is set for <c>pcre2_dfa_match()</c>, it returns <see cref="F:PCRE.PcreErrorCode.Partial"/> if the end of the subject is reached and there
            is still at least one matching possibility that requires additional characters.
            This happens even if some complete matches have already been found.
            </para>
            <para>
            When <see cref="F:PCRE.Dfa.PcreDfaMatchOptions.PartialSoft"/> is set, the return code <see cref="F:PCRE.PcreErrorCode.NoMatch"/> is converted into <see cref="F:PCRE.PcreErrorCode.Partial"/> if the end of the subject is reached,
            there have been no complete matches, but there is still at least one matching possibility.
            </para>
            <para>
            The portion of the string that was inspected when the longest partial match was found is set as the first matching string in both cases.
            There is a more detailed discussion of partial and multi-segment matching, with examples, in the pcre2partial documentation.
            </para>
            </remarks>
            <see cref="F:PCRE.PcreMatchOptions.PartialSoft"/>
        </member>
        <member name="F:PCRE.Dfa.PcreDfaMatchOptions.PartialHard">
            <summary>
            <c>PCRE2_PARTIAL_HARD</c> - Enable partial matching mode. Stop looking for a complete match if a partial match is found first.
            </summary>
            <remarks>
            <para>
            These have the same general effect as they do for <c>pcre2_match()</c>, but the details are slightly different.
            </para>
            <para>
            When <see cref="F:PCRE.Dfa.PcreDfaMatchOptions.PartialHard"/> is set for <c>pcre2_dfa_match()</c>, it returns <see cref="F:PCRE.PcreErrorCode.Partial"/> if the end of the subject is reached and there
            is still at least one matching possibility that requires additional characters.
            This happens even if some complete matches have already been found.
            </para>
            <para>
            When <see cref="F:PCRE.Dfa.PcreDfaMatchOptions.PartialSoft"/> is set, the return code <see cref="F:PCRE.PcreErrorCode.NoMatch"/> is converted into <see cref="F:PCRE.PcreErrorCode.Partial"/> if the end of the subject is reached,
            there have been no complete matches, but there is still at least one matching possibility.
            </para>
            <para>
            The portion of the string that was inspected when the longest partial match was found is set as the first matching string in both cases.
            There is a more detailed discussion of partial and multi-segment matching, with examples, in the pcre2partial documentation.
            </para>
            </remarks>
            <see cref="F:PCRE.PcreMatchOptions.PartialHard"/>
        </member>
        <member name="F:PCRE.Dfa.PcreDfaMatchOptions.DfaShortest">
            <summary>
            <c>PCRE2_DFA_SHORTEST</c> - Stop at the first (and therefore shortest) match.
            </summary>
            <remarks>
            Setting the <see cref="F:PCRE.Dfa.PcreDfaMatchOptions.DfaShortest"/> option causes the matching algorithm to stop as soon as it has found one match.
            Because of the way the alternative algorithm works, this is necessarily the shortest possible match at the first possible matching point in the subject string.
            </remarks>
        </member>
        <member name="T:PCRE.Dfa.PcreDfaMatchResult">
            <summary>
            Represents the result of one execution of the DFA algorithm. This contains several matches
            that start at the same index in the subject string. The longest match is returned first.
            </summary>
        </member>
        <member name="M:PCRE.Dfa.PcreDfaMatchResult.GetEnumerator">
            <summary>
            Enumerates the matches, from longest to shortest.
            </summary>
            <returns></returns>
        </member>
        <member name="P:PCRE.Dfa.PcreDfaMatchResult.Item(System.Int32)">
            <summary>
            Returns the match at a given index.
            </summary>
            <param name="index">The index of the match.</param>
        </member>
        <member name="P:PCRE.Dfa.PcreDfaMatchResult.Count">
            <summary>
            The available match count.
            </summary>
        </member>
        <member name="P:PCRE.Dfa.PcreDfaMatchResult.Success">
            <summary>
            Indicates if the match was successful.
            </summary>
        </member>
        <member name="P:PCRE.Dfa.PcreDfaMatchResult.Index">
            <summary>
            The starting index of the matches.
            </summary>
        </member>
        <member name="P:PCRE.Dfa.PcreDfaMatchResult.LongestMatch">
            <summary>
            Returns the longest match.
            </summary>
        </member>
        <member name="P:PCRE.Dfa.PcreDfaMatchResult.ShortestMatch">
            <summary>
            Returns the shortest match.
            </summary>
        </member>
        <member name="M:PCRE.Dfa.PcreDfaMatchResult.ToString">
            <summary>
            Returns the substring of the longest match in the subject string.
            </summary>
        </member>
        <member name="T:PCRE.Dfa.PcreDfaMatchSettings">
            <summary>
            The settings for a DFA match.
            </summary>
        </member>
        <member name="P:PCRE.Dfa.PcreDfaMatchSettings.AdditionalOptions">
            <summary>
            Additional options.
            </summary>
        </member>
        <member name="P:PCRE.Dfa.PcreDfaMatchSettings.StartIndex">
            <summary>
            The index at which the match should be attempted.
            </summary>
        </member>
        <member name="P:PCRE.Dfa.PcreDfaMatchSettings.MaxResults">
            <summary>
            The maximum number of results to return for a given match index.
            </summary>
        </member>
        <member name="P:PCRE.Dfa.PcreDfaMatchSettings.WorkspaceSize">
            <summary>
            The workspace vector size.
            </summary>
            <remarks>
            The workspace vector should contain at least 20 elements. It is used for keeping track of multiple paths through the pattern tree.
            More workspace is needed for patterns and subjects where there are a lot of potential matches.
            </remarks>
        </member>
        <member name="E:PCRE.Dfa.PcreDfaMatchSettings.OnCallout">
            <summary>
            A function to be called when a callout point is reached during the match.
            </summary>
        </member>
        <member name="T:PCRE.Dfa.PcreDfaRegex">
            <summary>
            DFA (deterministic finite automaton) matching API.
            </summary>
            <remarks>
            This is a matching algorithm that scans the subject string just once (not counting lookaround assertions), and does not backtrack.
            This has different characteristics to the normal algorithm, and is not compatible with Perl. Some of the features of PCRE2 patterns are not supported.
            </remarks>
        </member>
        <member name="M:PCRE.Dfa.PcreDfaRegex.Match(System.String)">
            <summary>
      Matches the regex against the given subject using the DFA algorithm.
    </summary>
            <param name="subject">The subject string to be matched.</param>
            <remarks>
            <para>
      The returned result represents all matches starting at the same index.
    </para>
            </remarks>
        </member>
        <member name="M:PCRE.Dfa.PcreDfaRegex.Match(System.String,PCRE.Dfa.PcreDfaMatchOptions)">
            <summary>
      Matches the regex against the given subject using the DFA algorithm.
    </summary>
            <param name="subject">The subject string to be matched.</param><param name="options">Additional options.</param>
            <remarks>
            <para>
      The returned result represents all matches starting at the same index.
    </para>
            </remarks>
        </member>
        <member name="M:PCRE.Dfa.PcreDfaRegex.Match(System.String,System.Int32)">
            <summary>
      Matches the regex against the given subject using the DFA algorithm.
    </summary>
            <param name="subject">The subject string to be matched.</param><param name="startIndex">The index at which the match should be attempted.</param>
            <remarks>
            <para>
      The returned result represents all matches starting at the same index.
    </para><para>
      Passing a non-zero
      <paramref name="startIndex" />
      differs from passing a shortened string if the pattern
      starts with an assertion (such as <c>\b</c>) or contains lookbehinds.
    </para>
            </remarks>
        </member>
        <member name="M:PCRE.Dfa.PcreDfaRegex.Match(System.String,System.Int32,PCRE.Dfa.PcreDfaMatchOptions)">
            <summary>
      Matches the regex against the given subject using the DFA algorithm.
    </summary>
            <param name="subject">The subject string to be matched.</param><param name="startIndex">The index at which the match should be attempted.</param><param name="options">Additional options.</param>
            <remarks>
            <para>
      The returned result represents all matches starting at the same index.
    </para><para>
      Passing a non-zero
      <paramref name="startIndex" />
      differs from passing a shortened string if the pattern
      starts with an assertion (such as <c>\b</c>) or contains lookbehinds.
    </para>
            </remarks>
        </member>
        <member name="M:PCRE.Dfa.PcreDfaRegex.Match(System.String,PCRE.Dfa.PcreDfaMatchSettings)">
            <summary>
      Matches the regex against the given subject using the DFA algorithm.
    </summary>
            <param name="subject">The subject string to be matched.</param><param name="settings">Additional advanced settings.</param>
            <remarks>
            <para>
      The returned result represents all matches starting at the same index.
    </para>
            </remarks>
        </member>
        <member name="M:PCRE.Dfa.PcreDfaRegex.Matches(System.String)">
            <summary>
      Returns an enumerable of all matches found in the given subject, using the DFA algorithm.
    </summary>
            <param name="subject">The subject string to be matched.</param>
            <remarks>
            <para>
      The returned result is a sequence of match results starting at different points in the subject string.
      Each item represents several matches starting at the same index in the subject string.
    </para>
            </remarks>
        </member>
        <member name="M:PCRE.Dfa.PcreDfaRegex.Matches(System.String,System.Int32)">
            <summary>
      Returns an enumerable of all matches found in the given subject, using the DFA algorithm.
    </summary>
            <param name="subject">The subject string to be matched.</param><param name="startIndex">The index at which the match should be attempted.</param>
            <remarks>
            <para>
      The returned result is a sequence of match results starting at different points in the subject string.
      Each item represents several matches starting at the same index in the subject string.
    </para><para>
      Passing a non-zero
      <paramref name="startIndex" />
      differs from passing a shortened string if the pattern
      starts with an assertion (such as <c>\b</c>) or contains lookbehinds.
    </para>
            </remarks>
        </member>
        <member name="M:PCRE.Dfa.PcreDfaRegex.Matches(System.String,PCRE.Dfa.PcreDfaMatchSettings)">
            <summary>
      Returns an enumerable of all matches found in the given subject, using the DFA algorithm.
    </summary>
            <param name="subject">The subject string to be matched.</param><param name="settings">Additional advanced settings.</param>
            <remarks>
            <para>
      The returned result is a sequence of match results starting at different points in the subject string.
      Each item represents several matches starting at the same index in the subject string.
    </para>
            </remarks>
        </member>
        <member name="T:PCRE.IPcreGroup">
            <summary>
            The result of a capturing group.
            </summary>
        </member>
        <member name="P:PCRE.IPcreGroup.Index">
            <summary>
            The start index of the group.
            </summary>
        </member>
        <member name="P:PCRE.IPcreGroup.EndIndex">
            <summary>
            The end index of the group.
            </summary>
        </member>
        <member name="P:PCRE.IPcreGroup.Length">
            <summary>
            The length of the group.
            </summary>
        </member>
        <member name="P:PCRE.IPcreGroup.Value">
            <summary>
            The value of the group.
            </summary>
        </member>
        <member name="P:PCRE.IPcreGroup.ValueSpan">
            <summary>
            The value of the group, as a <see cref="T:System.ReadOnlySpan`1"/>.
            </summary>
        </member>
        <member name="P:PCRE.IPcreGroup.Success">
            <summary>
            Indicates whether the group matched.
            </summary>
        </member>
        <member name="T:PCRE.IPcreGroupList">
            <summary>
            The list of capturing groups.
            </summary>
        </member>
        <member name="P:PCRE.IPcreGroupList.Item(System.String)">
            <summary>
            Returns the capturing group of a given name.
            </summary>
            <param name="name">The name of the capturing group.</param>
        </member>
        <member name="T:PCRE.PcreBackslashR">
            <summary>
            Indicates what character sequences the <c>\R</c> escape sequence matches by default.
            </summary>
        </member>
        <member name="F:PCRE.PcreBackslashR.Default">
            <summary>
            No information.
            </summary>
        </member>
        <member name="F:PCRE.PcreBackslashR.Unicode">
            <summary>
            <c>PCRE2_BSR_UNICODE</c> - <c>\R</c> matches any Unicode line ending sequence.
            </summary>
        </member>
        <member name="F:PCRE.PcreBackslashR.AnyCrLf">
            <summary>
            <c>PCRE2_BSR_ANYCRLF</c> - <c>\R</c> matches only CR, LF, or CRLF.
            </summary>
        </member>
        <member name="T:PCRE.PcreBuildInfo">
            <summary>
            Returns information about the PCRE build.
            </summary>
        </member>
        <member name="P:PCRE.PcreBuildInfo.BackslashR">
            <summary>
            <c>PCRE2_CONFIG_BSR</c> - Indicates what character sequences the <c>\R</c> escape sequence matches by default.
            </summary>
            <remarks>
            The default can be overridden when a pattern is compiled.
            </remarks>
        </member>
        <member name="P:PCRE.PcreBuildInfo.Jit">
            <summary>
            <c>PCRE2_CONFIG_JIT</c> - Indicates if support for just-in-time compiling is available.
            </summary>
        </member>
        <member name="P:PCRE.PcreBuildInfo.JitTarget">
            <summary>
            <c>PCRE2_CONFIG_JITTARGET</c> - Returns a string that contains the name of the architecture for which the JIT compiler is configured.
            </summary>
        </member>
        <member name="P:PCRE.PcreBuildInfo.LinkSize">
            <summary>
            <c>PCRE2_CONFIG_LINKSIZE</c> - Indicates the number of bytes used for internal linkage in compiled regular expressions.
            </summary>
        </member>
        <member name="P:PCRE.PcreBuildInfo.MatchLimit">
            <summary>
            <c>PCRE2_CONFIG_MATCHLIMIT</c> - Returns the default match limit.
            </summary>
        </member>
        <member name="P:PCRE.PcreBuildInfo.NewLine">
            <summary>
            <c>PCRE2_CONFIG_NEWLINE</c> - Indicates the default character sequence that is recognized as meaning "newline".
            </summary>
        </member>
        <member name="P:PCRE.PcreBuildInfo.ParensLimit">
            <summary>
            <c>PCRE2_CONFIG_PARENSLIMIT</c> - Returns the maximum depth of nesting of parentheses (of any kind) in a pattern.
            </summary>
            <remarks>
            This limit is imposed to cap the amount of system stack used when a pattern is compiled.
            </remarks>
        </member>
        <member name="P:PCRE.PcreBuildInfo.DepthLimit">
            <summary>
            <c>PCRE2_CONFIG_DEPTHLIMIT</c> - Returns the default limit for the depth of nested backtracking in NFA matching or the depth of nested recursions, lookarounds, and atomic groups in DFA matching.
            </summary>
        </member>
        <member name="P:PCRE.PcreBuildInfo.Unicode">
            <summary>
            <c>PCRE2_CONFIG_UNICODE</c> - Indicates if Unicode support is available.
            </summary>
        </member>
        <member name="P:PCRE.PcreBuildInfo.UnicodeVersion">
            <summary>
            <c>PCRE2_CONFIG_UNICODE_VERSION</c> - Returns the supported Unicode version.
            </summary>
        </member>
        <member name="P:PCRE.PcreBuildInfo.Version">
            <summary>
            <c>PCRE2_CONFIG_VERSION</c> - Returns the PCRE2 version string.
            </summary>
        </member>
        <member name="P:PCRE.PcreBuildInfo.HeapLimit">
            <summary>
            <c>PCRE2_CONFIG_HEAPLIMIT</c> - Returns the default limit for the amount of heap memory used for matching, in kibibytes.
            </summary>
        </member>
        <member name="P:PCRE.PcreBuildInfo.NeverBackslashC">
            <summary>
            <c>PCRE2_CONFIG_NEVER_BACKSLASH_C</c> - Indicates if the use of <c>\C</c> was permanently disabled when PCRE2 was built
            </summary>
        </member>
        <member name="P:PCRE.PcreBuildInfo.CompiledWidths">
            <summary>
            <c>PCRE2_CONFIG_COMPILED_WIDTHS</c> - Indicates which code unit widths were selected when PCRE2 was built.
            </summary>
            <remarks>
            The 1-bit indicates 8-bit support, and the 2-bit and 4-bit indicate 16-bit and 32-bit support, respectively.
            </remarks>
        </member>
        <member name="P:PCRE.PcreBuildInfo.TablesLength">
            <summary>
            <c>PCRE2_CONFIG_TABLES_LENGTH</c> - Gives the length of PCRE2's character processing tables in bytes.
            </summary>
        </member>
        <member name="T:PCRE.PcreCallout">
            <summary>
            Represents the state during a callout invocation.
            </summary>
        </member>
        <member name="P:PCRE.PcreCallout.Number">
            <inheritdoc cref="P:PCRE.PcreCalloutInfo.Number"/>
        </member>
        <member name="P:PCRE.PcreCallout.Match">
            <summary>
            Returns the current match status.
            </summary>
        </member>
        <member name="P:PCRE.PcreCallout.StartOffset">
            <summary>
            The offset within the subject at which the current match attempt started.
            </summary>
            <remarks>
            If the escape sequence <c>\K</c> has been encountered, this value is changed to reflect the modified starting point.
            If the pattern is not anchored, the callout function may be called several times from the same point in the pattern for different starting points in the subject.
            </remarks>
        </member>
        <member name="P:PCRE.PcreCallout.CurrentOffset">
            <summary>
            The offset within the subject of the current match pointer.
            </summary>
        </member>
        <member name="P:PCRE.PcreCallout.MaxCapture">
            <summary>
            One more than the number of the highest numbered captured substring so far.
            </summary>
            <remarks>
            If no substrings have yet been captured, the value is 1.
            </remarks>
        </member>
        <member name="P:PCRE.PcreCallout.LastCapture">
            <summary>
            The number of the most recently captured substring.
            </summary>
            <remarks>
            If no substrings have yet been captured, the value is 0.
            </remarks>
        </member>
        <member name="P:PCRE.PcreCallout.PatternPosition">
            <inheritdoc cref="P:PCRE.PcreCalloutInfo.PatternPosition"/>
        </member>
        <member name="P:PCRE.PcreCallout.NextPatternItemLength">
            <inheritdoc cref="P:PCRE.PcreCalloutInfo.NextPatternItemLength"/>
        </member>
        <member name="P:PCRE.PcreCallout.StringOffset">
            <inheritdoc cref="P:PCRE.PcreCalloutInfo.StringOffset"/>
        </member>
        <member name="P:PCRE.PcreCallout.String">
            <inheritdoc cref="P:PCRE.PcreCalloutInfo.String"/>
        </member>
        <member name="P:PCRE.PcreCallout.Info">
            <summary>
            Returns information about the callout.
            </summary>
        </member>
        <member name="P:PCRE.PcreCallout.StartMatch">
            <summary>
            <c>PCRE2_CALLOUT_STARTMATCH</c> - This is set for the first callout after the start of matching for each new starting position in the subject.
            </summary>
            <remarks>
            Always false for DFA matching, or if the JIT is used.
            </remarks>
        </member>
        <member name="P:PCRE.PcreCallout.Backtrack">
            <summary>
            <c>PCRE2_CALLOUT_BACKTRACK</c> - This is set if there has been a matching backtrack since the previous callout, or since the start of matching if this is the first callout from a match run.
            </summary>
            <remarks>
            Always false for DFA matching, or if the JIT is used.
            </remarks>
        </member>
        <member name="T:PCRE.PcreCalloutInfo">
            <summary>
            Information about a callout in the regex pattern.
            </summary>
        </member>
        <member name="P:PCRE.PcreCalloutInfo.Number">
            <summary>
            The number associated with the callout, or zero for named callouts.
            </summary>
        </member>
        <member name="P:PCRE.PcreCalloutInfo.String">
            <summary>
            The name of the callout, or null for numeric callouts.
            </summary>
        </member>
        <member name="P:PCRE.PcreCalloutInfo.NextPatternItemLength">
            <summary>
            The length of the next item to be processed in the pattern string.
            </summary>
            <remarks>
            When the callout is at the end of the pattern, the length is zero. When the callout precedes an opening parenthesis,
            the length includes meta characters that follow the parenthesis. For example, in a callout before an assertion such as
            <c>(?=ab)</c> the length is 3. For an an alternation bar or a closing parenthesis, the length is one, unless a closing
            parenthesis is followed by a quantifier, in which case its length is included.
            </remarks>
        </member>
        <member name="P:PCRE.PcreCalloutInfo.PatternPosition">
            <summary>
            The position of the callout in the pattern.
            </summary>
        </member>
        <member name="P:PCRE.PcreCalloutInfo.StringOffset">
            <summary>
            The code unit offset to the start of the callout argument string within the original pattern string.
            </summary>
        </member>
        <member name="T:PCRE.PcreCalloutResult">
            <summary>
            Specifies the result of a callout.
            </summary>
        </member>
        <member name="F:PCRE.PcreCalloutResult.Pass">
            <summary>
            Treat the callout as passing, and continue matching.
            </summary>
        </member>
        <member name="F:PCRE.PcreCalloutResult.Fail">
            <summary>
            Treat the callout as failing, just as if a lookahead assertion had failed at this point.
            </summary>
        </member>
        <member name="F:PCRE.PcreCalloutResult.Abort">
            <summary>
            Fail the whole match.
            </summary>
        </member>
        <member name="T:PCRE.PcreErrorCode">
            <summary>
            An error code returned by PCRE.
            </summary>
        </member>
        <member name="F:PCRE.PcreErrorCode.None">
            <summary>
            No error.
            </summary>
        </member>
        <member name="F:PCRE.PcreErrorCode.EndBackslash">
            <summary>
            <c>PCRE2_ERROR_END_BACKSLASH</c> - <c>\</c> at end of pattern.
            </summary>
        </member>
        <member name="F:PCRE.PcreErrorCode.EndBackslashC">
            <summary>
            <c>PCRE2_ERROR_END_BACKSLASH_C</c> - <c>\c</c> at end of pattern.
            </summary>
        </member>
        <member name="F:PCRE.PcreErrorCode.UnknownEscape">
            <summary>
            <c>PCRE2_ERROR_UNKNOWN_ESCAPE</c> - Unrecognized character follows <c>\</c>
            </summary>
        </member>
        <member name="F:PCRE.PcreErrorCode.QuantifierOutOfOrder">
            <summary>
            <c>PCRE2_ERROR_QUANTIFIER_OUT_OF_ORDER</c> - Numbers out of order in <c>{}</c> quantifier.
            </summary>
        </member>
        <member name="F:PCRE.PcreErrorCode.QuantifierTooBig">
            <summary>
            <c>PCRE2_ERROR_QUANTIFIER_TOO_BIG</c> - Number too big in <c>{}</c> quantifier.
            </summary>
        </member>
        <member name="F:PCRE.PcreErrorCode.MissingSquareBracket">
            <summary>
            <c>PCRE2_ERROR_MISSING_SQUARE_BRACKET</c> - Missing terminating <c>]</c> for character class.
            </summary>
        </member>
        <member name="F:PCRE.PcreErrorCode.EscapeInvalidInClass">
            <summary>
            <c>PCRE2_ERROR_ESCAPE_INVALID_IN_CLASS</c> - Escape sequence is invalid in character class.
            </summary>
        </member>
        <member name="F:PCRE.PcreErrorCode.ClassRangeOrder">
            <summary>
            <c>PCRE2_ERROR_CLASS_RANGE_ORDER</c> - Range out of order in character class.
            </summary>
        </member>
        <member name="F:PCRE.PcreErrorCode.QuantifierInvalid">
            <summary>
            <c>PCRE2_ERROR_QUANTIFIER_INVALID</c> - Quantifier does not follow a repeatable item.
            </summary>
        </member>
        <member name="F:PCRE.PcreErrorCode.InternalUnexpectedRepeat">
            <summary>
            <c>PCRE2_ERROR_INTERNAL_UNEXPECTED_REPEAT</c> - Internal error: unexpected repeat.
            </summary>
        </member>
        <member name="F:PCRE.PcreErrorCode.InvalidAfterParensQuery">
            <summary>
            <c>PCRE2_ERROR_INVALID_AFTER_PARENS_QUERY</c> - Unrecognized character after <c>(?</c> or <c>(?-</c>
            </summary>
        </member>
        <member name="F:PCRE.PcreErrorCode.PosixClassNotInClass">
            <summary>
            <c>PCRE2_ERROR_POSIX_CLASS_NOT_IN_CLASS</c> - POSIX named classes are supported only within a class.
            </summary>
        </member>
        <member name="F:PCRE.PcreErrorCode.PosixNoSupportCollating">
            <summary>
            <c>PCRE2_ERROR_POSIX_NO_SUPPORT_COLLATING</c> - POSIX collating elements are not supported.
            </summary>
        </member>
        <member name="F:PCRE.PcreErrorCode.MissingClosingParenthesis">
            <summary>
            <c>PCRE2_ERROR_MISSING_CLOSING_PARENTHESIS</c> - Missing closing parenthesis.
            </summary>
        </member>
        <member name="F:PCRE.PcreErrorCode.BadSubpatternReference">
            <summary>
            <c>PCRE2_ERROR_BAD_SUBPATTERN_REFERENCE</c> - Reference to non-existent subpattern.
            </summary>
        </member>
        <member name="F:PCRE.PcreErrorCode.NullPattern">
            <summary>
            <c>PCRE2_ERROR_NULL_PATTERN</c> - Pattern passed as NULL.
            </summary>
        </member>
        <member name="F:PCRE.PcreErrorCode.BadOptions">
            <summary>
            <c>PCRE2_ERROR_BAD_OPTIONS</c> - Unrecognised compile-time option bit(s).
            </summary>
        </member>
        <member name="F:PCRE.PcreErrorCode.MissingCommentClosing">
            <summary>
            <c>PCRE2_ERROR_MISSING_COMMENT_CLOSING</c> - Missing <c>)</c> after <c>(?#</c> comment.
            </summary>
        </member>
        <member name="F:PCRE.PcreErrorCode.ParenthesesNestTooDeep">
            <summary>
            <c>PCRE2_ERROR_PARENTHESES_NEST_TOO_DEEP</c> - Parentheses are too deeply nested.
            </summary>
        </member>
        <member name="F:PCRE.PcreErrorCode.PatternTooLarge">
            <summary>
            <c>PCRE2_ERROR_PATTERN_TOO_LARGE</c> - Regular expression is too large.
            </summary>
        </member>
        <member name="F:PCRE.PcreErrorCode.HeapFailed">
            <summary>
            <c>PCRE2_ERROR_HEAP_FAILED</c> - Failed to allocate heap memory.
            </summary>
        </member>
        <member name="F:PCRE.PcreErrorCode.UnmatchedClosingParenthesis">
            <summary>
            <c>PCRE2_ERROR_UNMATCHED_CLOSING_PARENTHESIS</c> - Unmatched closing parenthesis.
            </summary>
        </member>
        <member name="F:PCRE.PcreErrorCode.InternalCodeOverflow">
            <summary>
            <c>PCRE2_ERROR_INTERNAL_CODE_OVERFLOW</c> - Internal error: code overflow.
            </summary>
        </member>
        <member name="F:PCRE.PcreErrorCode.MissingConditionClosing">
            <summary>
            <c>PCRE2_ERROR_MISSING_CONDITION_CLOSING</c> - Missing closing parenthesis for condition.
            </summary>
        </member>
        <member name="F:PCRE.PcreErrorCode.LookbehindNotFixedLength">
            <summary>
            <c>PCRE2_ERROR_LOOKBEHIND_NOT_FIXED_LENGTH</c> - Lookbehind assertion is not fixed length.
            </summary>
        </member>
        <member name="F:PCRE.PcreErrorCode.ZeroRelativeReference">
            <summary>
            <c>PCRE2_ERROR_ZERO_RELATIVE_REFERENCE</c> - A relative value of zero is not allowed.
            </summary>
        </member>
        <member name="F:PCRE.PcreErrorCode.TooManyConditionBranches">
            <summary>
            <c>PCRE2_ERROR_TOO_MANY_CONDITION_BRANCHES</c> - Conditional subpattern contains more than two branches.
            </summary>
        </member>
        <member name="F:PCRE.PcreErrorCode.ConditionAssertionExpected">
            <summary>
            <c>PCRE2_ERROR_CONDITION_ASSERTION_EXPECTED</c> - Assertion expected after <c>(?(</c> or <c>(?(?C)</c>
            </summary>
        </member>
        <member name="F:PCRE.PcreErrorCode.BadRelativeReference">
            <summary>
            <c>PCRE2_ERROR_BAD_RELATIVE_REFERENCE</c> - Digit expected after <c>(?+</c> or <c>(?-</c>
            </summary>
        </member>
        <member name="F:PCRE.PcreErrorCode.UnknownPosixClass">
            <summary>
            <c>PCRE2_ERROR_UNKNOWN_POSIX_CLASS</c> - Unknown POSIX class name.
            </summary>
        </member>
        <member name="F:PCRE.PcreErrorCode.InternalStudyError">
            <summary>
            <c>PCRE2_ERROR_INTERNAL_STUDY_ERROR</c> - Internal error in <c>pcre2_study()</c>: should not occur.
            </summary>
        </member>
        <member name="F:PCRE.PcreErrorCode.UnicodeNotSupported">
            <summary>
            <c>PCRE2_ERROR_UNICODE_NOT_SUPPORTED</c> - This version of PCRE2 does not have Unicode support.
            </summary>
        </member>
        <member name="F:PCRE.PcreErrorCode.ParenthesesStackCheck">
            <summary>
            <c>PCRE2_ERROR_PARENTHESES_STACK_CHECK</c> - Parentheses are too deeply nested (stack check).
            </summary>
        </member>
        <member name="F:PCRE.PcreErrorCode.CodePointTooBig">
            <summary>
            <c>PCRE2_ERROR_CODE_POINT_TOO_BIG</c> - Character code point value in <c>\x{}</c> or <c>\o{}</c> is too large.
            </summary>
        </member>
        <member name="F:PCRE.PcreErrorCode.LookbehindTooComplicated">
            <summary>
            <c>PCRE2_ERROR_LOOKBEHIND_TOO_COMPLICATED</c> - Lookbehind is too complicated.
            </summary>
        </member>
        <member name="F:PCRE.PcreErrorCode.LookbehindInvalidBackslashC">
            <summary>
            <c>PCRE2_ERROR_LOOKBEHIND_INVALID_BACKSLASH_C</c> - <c>\C</c> is not allowed in a lookbehind assertion in UTF-16 mode.
            </summary>
        </member>
        <member name="F:PCRE.PcreErrorCode.UnsupportedEscapeSequence">
            <summary>
            <c>PCRE2_ERROR_UNSUPPORTED_ESCAPE_SEQUENCE</c> - PCRE2 does not support <c>\F</c>, <c>\L</c>, <c>\l</c>, <c>\N{name}</c>, <c>\U</c>, or <c>\u</c>
            </summary>
        </member>
        <member name="F:PCRE.PcreErrorCode.CalloutNumberTooBig">
            <summary>
            <c>PCRE2_ERROR_CALLOUT_NUMBER_TOO_BIG</c> - Number after <c>(?C</c> is greater than 255.
            </summary>
        </member>
        <member name="F:PCRE.PcreErrorCode.MissingCalloutClosing">
            <summary>
            <c>PCRE2_ERROR_MISSING_CALLOUT_CLOSING</c> - Closing parenthesis for <c>(?C</c> expected.
            </summary>
        </member>
        <member name="F:PCRE.PcreErrorCode.EscapeInvalidInVerb">
            <summary>
            <c>PCRE2_ERROR_ESCAPE_INVALID_IN_VERB</c> - Invalid escape sequence in <c>(*VERB)</c> name.
            </summary>
        </member>
        <member name="F:PCRE.PcreErrorCode.UnrecognizedAfterQueryP">
            <summary>
            <c>PCRE2_ERROR_UNRECOGNIZED_AFTER_QUERY_P</c> - Unrecognized character after <c>(?P</c>
            </summary>
        </member>
        <member name="F:PCRE.PcreErrorCode.MissingNameTerminator">
            <summary>
            <c>PCRE2_ERROR_MISSING_NAME_TERMINATOR</c> - Syntax error in subpattern name (missing terminator?).
            </summary>
        </member>
        <member name="F:PCRE.PcreErrorCode.DuplicateSubpatternName">
            <summary>
            <c>PCRE2_ERROR_DUPLICATE_SUBPATTERN_NAME</c> - Two named subpatterns have the same name (<see cref="F:PCRE.PcreOptions.DupNames"/> not set).
            </summary>
        </member>
        <member name="F:PCRE.PcreErrorCode.InvalidSubpatternName">
            <summary>
            <c>PCRE2_ERROR_INVALID_SUBPATTERN_NAME</c> - Subpattern name must start with a non-digit.
            </summary>
        </member>
        <member name="F:PCRE.PcreErrorCode.UnicodePropertiesUnavailable">
            <summary>
            <c>PCRE2_ERROR_UNICODE_PROPERTIES_UNAVAILABLE</c> - This version of PCRE2 does not have support for <c>\P</c>, \p, or <c>\X</c>
            </summary>
        </member>
        <member name="F:PCRE.PcreErrorCode.MalformedUnicodeProperty">
            <summary>
            <c>PCRE2_ERROR_MALFORMED_UNICODE_PROPERTY</c> - Malformed <c>\P</c> or <c>\p</c> sequence.
            </summary>
        </member>
        <member name="F:PCRE.PcreErrorCode.UnknownUnicodeProperty">
            <summary>
            <c>PCRE2_ERROR_UNKNOWN_UNICODE_PROPERTY</c> - Unknown property name after <c>\P</c> or <c>\p</c>
            </summary>
        </member>
        <member name="F:PCRE.PcreErrorCode.SubpatternNameTooLong">
            <summary>
            <c>PCRE2_ERROR_SUBPATTERN_NAME_TOO_LONG</c> - Subpattern name is too long (maximum 32 code units).
            </summary>
        </member>
        <member name="F:PCRE.PcreErrorCode.TooManyNamedSubpatterns">
            <summary>
            <c>PCRE2_ERROR_TOO_MANY_NAMED_SUBPATTERNS</c> - Too many named subpatterns (maximum 10000).
            </summary>
        </member>
        <member name="F:PCRE.PcreErrorCode.ClassInvalidRange">
            <summary>
            <c>PCRE2_ERROR_CLASS_INVALID_RANGE</c> - Invalid range in character class.
            </summary>
        </member>
        <member name="F:PCRE.PcreErrorCode.OctalByteTooBig">
            <summary>
            <c>PCRE2_ERROR_OCTAL_BYTE_TOO_BIG</c> - Octal value is greater than <c>\377</c> in 8-bit non-UTF-8 mode.
            </summary>
        </member>
        <member name="F:PCRE.PcreErrorCode.InternalOverranWorkspace">
            <summary>
            <c>PCRE2_ERROR_INTERNAL_OVERRAN_WORKSPACE</c> - Internal error: overran compiling workspace.
            </summary>
        </member>
        <member name="F:PCRE.PcreErrorCode.InternalMissingSubpattern">
            <summary>
            <c>PCRE2_ERROR_INTERNAL_MISSING_SUBPATTERN</c> - Internal error: previously-checked referenced subpattern not found.
            </summary>
        </member>
        <member name="F:PCRE.PcreErrorCode.DefineTooManyBranches">
            <summary>
            <c>PCRE2_ERROR_DEFINE_TOO_MANY_BRANCHES</c> - <c>DEFINE</c> subpattern contains more than one branch.
            </summary>
        </member>
        <member name="F:PCRE.PcreErrorCode.BackslashOMissingBrace">
            <summary>
            <c>PCRE2_ERROR_BACKSLASH_O_MISSING_BRACE</c> - Missing opening brace after <c>\o</c>
            </summary>
        </member>
        <member name="F:PCRE.PcreErrorCode.InternalUnknownNewline">
            <summary>
            <c>PCRE2_ERROR_INTERNAL_UNKNOWN_NEWLINE</c> - Internal error: unknown newline setting.
            </summary>
        </member>
        <member name="F:PCRE.PcreErrorCode.BackslashGSyntax">
            <summary>
            <c>PCRE2_ERROR_BACKSLASH_G_SYNTAX</c> - <c>\g</c> is not followed by a braced, angle-bracketed, or quoted name/number or by a plain number.
            </summary>
        </member>
        <member name="F:PCRE.PcreErrorCode.ParensQueryRMissingClosing">
            <summary>
            <c>PCRE2_ERROR_PARENS_QUERY_R_MISSING_CLOSING</c> - <c>(?R</c> (recursive pattern call) must be followed by a closing parenthesis.
            </summary>
        </member>
        <member name="F:PCRE.PcreErrorCode.VerbArgumentNotAllowed">
            <summary>
            <c>PCRE2_ERROR_VERB_ARGUMENT_NOT_ALLOWED</c> - Obsolete error (should not occur).
            </summary>
        </member>
        <member name="F:PCRE.PcreErrorCode.VerbUnknown">
            <summary>
            <c>PCRE2_ERROR_VERB_UNKNOWN</c> - <c>(*VERB)</c> not recognized or malformed.
            </summary>
        </member>
        <member name="F:PCRE.PcreErrorCode.SubpatternNumberTooBig">
            <summary>
            <c>PCRE2_ERROR_SUBPATTERN_NUMBER_TOO_BIG</c> - Subpattern number is too big.
            </summary>
        </member>
        <member name="F:PCRE.PcreErrorCode.SubpatternNameExpected">
            <summary>
            <c>PCRE2_ERROR_SUBPATTERN_NAME_EXPECTED</c> - Subpattern name expected.
            </summary>
        </member>
        <member name="F:PCRE.PcreErrorCode.InternalParsedOverflow">
            <summary>
            <c>PCRE2_ERROR_INTERNAL_PARSED_OVERFLOW</c> - Internal error: parsed pattern overflow.
            </summary>
        </member>
        <member name="F:PCRE.PcreErrorCode.InvalidOctal">
            <summary>
            <c>PCRE2_ERROR_INVALID_OCTAL</c> - Non-octal character in <c>\o{}</c> (closing brace missing?).
            </summary>
        </member>
        <member name="F:PCRE.PcreErrorCode.SubpatternNamesMismatch">
            <summary>
            <c>PCRE2_ERROR_SUBPATTERN_NAMES_MISMATCH</c> - Different names for subpatterns of the same number are not allowed.
            </summary>
        </member>
        <member name="F:PCRE.PcreErrorCode.MarkMissingArgument">
            <summary>
            <c>PCRE2_ERROR_MARK_MISSING_ARGUMENT</c> - <c>(*MARK)</c> must have an argument.
            </summary>
        </member>
        <member name="F:PCRE.PcreErrorCode.InvalidHexadecimal">
            <summary>
            <c>PCRE2_ERROR_INVALID_HEXADECIMAL</c> - Non-hex character in <c>\x{}</c> (closing brace missing?).
            </summary>
        </member>
        <member name="F:PCRE.PcreErrorCode.BackslashCSyntax">
            <summary>
            <c>PCRE2_ERROR_BACKSLASH_C_SYNTAX</c> - <c>\c</c> must be followed by a printable ASCII character.
            </summary>
        </member>
        <member name="F:PCRE.PcreErrorCode.BackslashKSyntax">
            <summary>
            <c>PCRE2_ERROR_BACKSLASH_K_SYNTAX</c> - <c>\k</c> is not followed by a braced, angle-bracketed, or quoted name.
            </summary>
        </member>
        <member name="F:PCRE.PcreErrorCode.InternalBadCodeLookbehinds">
            <summary>
            <c>PCRE2_ERROR_INTERNAL_BAD_CODE_LOOKBEHINDS</c> - Internal error: unknown meta code in <c>check_lookbehinds()</c>.
            </summary>
        </member>
        <member name="F:PCRE.PcreErrorCode.BackslashNInClass">
            <summary>
            <c>PCRE2_ERROR_BACKSLASH_N_IN_CLASS</c> - <c>\N</c> is not supported in a class.
            </summary>
        </member>
        <member name="F:PCRE.PcreErrorCode.CalloutStringTooLong">
            <summary>
            <c>PCRE2_ERROR_CALLOUT_STRING_TOO_LONG</c> - Callout string is too long.
            </summary>
        </member>
        <member name="F:PCRE.PcreErrorCode.UnicodeDisallowedCodePoint">
            <summary>
            <c>PCRE2_ERROR_UNICODE_DISALLOWED_CODE_POINT</c> - Disallowed Unicode code point (&gt;= 0xd800 &amp;&amp; &lt;= 0xdfff).
            </summary>
        </member>
        <member name="F:PCRE.PcreErrorCode.UtfIsDisabled">
            <summary>
            <c>PCRE2_ERROR_UTF_IS_DISABLED</c> - Using UTF is disabled by the application.
            </summary>
        </member>
        <member name="F:PCRE.PcreErrorCode.UcpIsDisabled">
            <summary>
            <c>PCRE2_ERROR_UCP_IS_DISABLED</c> - Using UCP is disabled by the application.
            </summary>
        </member>
        <member name="F:PCRE.PcreErrorCode.VerbNameTooLong">
            <summary>
            <c>PCRE2_ERROR_VERB_NAME_TOO_LONG</c> - Name is too long in <c>(*MARK)</c>, <c>(*PRUNE)</c>, <c>(*SKIP)</c>, or <c>(*THEN)</c>
            </summary>
        </member>
        <member name="F:PCRE.PcreErrorCode.BackslashUCodePointTooBig">
            <summary>
            <c>PCRE2_ERROR_BACKSLASH_U_CODE_POINT_TOO_BIG</c> - Character code point value in <c>\u....</c> sequence is too large.
            </summary>
        </member>
        <member name="F:PCRE.PcreErrorCode.MissingOctalOrHexDigits">
            <summary>
            <c>PCRE2_ERROR_MISSING_OCTAL_OR_HEX_DIGITS</c> - Digits missing in <c>\x{}</c> or <c>\o{}</c> or <c>\N{U+}</c>
            </summary>
        </member>
        <member name="F:PCRE.PcreErrorCode.VersionConditionSyntax">
            <summary>
            <c>PCRE2_ERROR_VERSION_CONDITION_SYNTAX</c> - Syntax error or number too big in <c>(?(VERSION</c> condition.
            </summary>
        </member>
        <member name="F:PCRE.PcreErrorCode.InternalBadCodeAutoPossess">
            <summary>
            <c>PCRE2_ERROR_INTERNAL_BAD_CODE_AUTO_POSSESS</c> - Internal error: unknown opcode in <c>auto_possessify()</c>.
            </summary>
        </member>
        <member name="F:PCRE.PcreErrorCode.CalloutNoStringDelimiter">
            <summary>
            <c>PCRE2_ERROR_CALLOUT_NO_STRING_DELIMITER</c> - Missing terminating delimiter for callout with string argument.
            </summary>
        </member>
        <member name="F:PCRE.PcreErrorCode.CalloutBadStringDelimiter">
            <summary>
            <c>PCRE2_ERROR_CALLOUT_BAD_STRING_DELIMITER</c> - Unrecognized string delimiter follows <c>(?C</c>
            </summary>
        </member>
        <member name="F:PCRE.PcreErrorCode.BackslashCCallerDisabled">
            <summary>
            <c>PCRE2_ERROR_BACKSLASH_C_CALLER_DISABLED</c> - Using <c>\C</c> is disabled by the application.
            </summary>
        </member>
        <member name="F:PCRE.PcreErrorCode.QueryBarJxNestTooDeep">
            <summary>
            <c>PCRE2_ERROR_QUERY_BARJX_NEST_TOO_DEEP</c> - <c>(?|</c> and/or <c>(?J:</c> or <c>(?x:</c> parentheses are too deeply nested.
            </summary>
        </member>
        <member name="F:PCRE.PcreErrorCode.BackslashCLibraryDisabled">
            <summary>
            <c>PCRE2_ERROR_BACKSLASH_C_LIBRARY_DISABLED</c> - Using <c>\C</c> is disabled in this PCRE2 library.
            </summary>
        </member>
        <member name="F:PCRE.PcreErrorCode.PatternTooComplicated">
            <summary>
            <c>PCRE2_ERROR_PATTERN_TOO_COMPLICATED</c> - Regular expression is too complicated.
            </summary>
        </member>
        <member name="F:PCRE.PcreErrorCode.LookbehindTooLong">
            <summary>
            <c>PCRE2_ERROR_LOOKBEHIND_TOO_LONG</c> - Lookbehind assertion is too long.
            </summary>
        </member>
        <member name="F:PCRE.PcreErrorCode.PatternStringTooLong">
            <summary>
            <c>PCRE2_ERROR_PATTERN_STRING_TOO_LONG</c> - Pattern string is longer than the limit set by the application.
            </summary>
        </member>
        <member name="F:PCRE.PcreErrorCode.InternalBadCode">
            <summary>
            <c>PCRE2_ERROR_INTERNAL_BAD_CODE</c> - Internal error: unknown code in parsed pattern.
            </summary>
        </member>
        <member name="F:PCRE.PcreErrorCode.InternalBadCodeInSkip">
            <summary>
            <c>PCRE2_ERROR_INTERNAL_BAD_CODE_IN_SKIP</c> - Internal error: bad code value in <c>parsed_skip()</c>.
            </summary>
        </member>
        <member name="F:PCRE.PcreErrorCode.NoSurrogatesInUtf16">
            <summary>
            <c>PCRE2_ERROR_NO_SURROGATES_IN_UTF16</c> - <see cref="F:PCRE.PcreExtraCompileOptions.AllowSurrogateEscapes"/> is not allowed in UTF-16 mode.
            </summary>
        </member>
        <member name="F:PCRE.PcreErrorCode.BadLiteralOptions">
            <summary>
            <c>PCRE2_ERROR_BAD_LITERAL_OPTIONS</c> - Invalid option bits with <see cref="F:PCRE.PcreOptions.Literal"/>.
            </summary>
        </member>
        <member name="F:PCRE.PcreErrorCode.SupportedOnlyInUnicode">
            <summary>
            <c>PCRE2_ERROR_SUPPORTED_ONLY_IN_UNICODE</c> - <c>\N{U+dddd}</c> is supported only in Unicode (UTF) mode.
            </summary>
        </member>
        <member name="F:PCRE.PcreErrorCode.InvalidHyphenInOptions">
            <summary>
            <c>PCRE2_ERROR_INVALID_HYPHEN_IN_OPTIONS</c> - Invalid hyphen in option setting.
            </summary>
        </member>
        <member name="F:PCRE.PcreErrorCode.AlphaAssertionUnknown">
            <summary>
            <c>PCRE2_ERROR_ALPHA_ASSERTION_UNKNOWN</c> - <c>(*alpha_assertion)</c> not recognized.
            </summary>
        </member>
        <member name="F:PCRE.PcreErrorCode.ScriptRunNotAvailable">
            <summary>
            <c>PCRE2_ERROR_SCRIPT_RUN_NOT_AVAILABLE</c> - Script runs require Unicode support, which this version of PCRE2 does not have.
            </summary>
        </member>
        <member name="F:PCRE.PcreErrorCode.TooManyCaptures">
            <summary>
            <c>PCRE2_ERROR_TOO_MANY_CAPTURES</c> - Too many capturing groups (maximum 65535).
            </summary>
        </member>
        <member name="F:PCRE.PcreErrorCode.ConditionAtomicAssertionExpected">
            <summary>
            <c>PCRE2_ERROR_CONDITION_ATOMIC_ASSERTION_EXPECTED</c> - Atomic assertion expected after <c>(?(</c> or <c>(?(?C)</c>
            </summary>
        </member>
        <member name="F:PCRE.PcreErrorCode.BackslashKInLookaround">
            <summary>
            <c>PCRE2_ERROR_BACKSLASH_K_IN_LOOKAROUND</c> - <c>\K</c> is not allowed in lookarounds (but see <see cref="F:PCRE.PcreExtraCompileOptions.AllowLookaroundBsK"/>).
            </summary>
        </member>
        <member name="F:PCRE.PcreErrorCode.NoMatch">
            <summary>
            <c>PCRE2_ERROR_NOMATCH</c> - No match.
            </summary>
        </member>
        <member name="F:PCRE.PcreErrorCode.Partial">
            <summary>
            <c>PCRE2_ERROR_PARTIAL</c> - Partial match.
            </summary>
        </member>
        <member name="F:PCRE.PcreErrorCode.Utf8Err1">
            <summary>
            <c>PCRE2_ERROR_UTF8_ERR1</c> - UTF-8 error: 1 byte missing at end.
            </summary>
        </member>
        <member name="F:PCRE.PcreErrorCode.Utf8Err2">
            <summary>
            <c>PCRE2_ERROR_UTF8_ERR2</c> - UTF-8 error: 2 bytes missing at end.
            </summary>
        </member>
        <member name="F:PCRE.PcreErrorCode.Utf8Err3">
            <summary>
            <c>PCRE2_ERROR_UTF8_ERR3</c> - UTF-8 error: 3 bytes missing at end.
            </summary>
        </member>
        <member name="F:PCRE.PcreErrorCode.Utf8Err4">
            <summary>
            <c>PCRE2_ERROR_UTF8_ERR4</c> - UTF-8 error: 4 bytes missing at end.
            </summary>
        </member>
        <member name="F:PCRE.PcreErrorCode.Utf8Err5">
            <summary>
            <c>PCRE2_ERROR_UTF8_ERR5</c> - UTF-8 error: 5 bytes missing at end.
            </summary>
        </member>
        <member name="F:PCRE.PcreErrorCode.Utf8Err6">
            <summary>
            <c>PCRE2_ERROR_UTF8_ERR6</c> - UTF-8 error: byte 2 top bits not 0x80.
            </summary>
        </member>
        <member name="F:PCRE.PcreErrorCode.Utf8Err7">
            <summary>
            <c>PCRE2_ERROR_UTF8_ERR7</c> - UTF-8 error: byte 3 top bits not 0x80.
            </summary>
        </member>
        <member name="F:PCRE.PcreErrorCode.Utf8Err8">
            <summary>
            <c>PCRE2_ERROR_UTF8_ERR8</c> - UTF-8 error: byte 4 top bits not 0x80.
            </summary>
        </member>
        <member name="F:PCRE.PcreErrorCode.Utf8Err9">
            <summary>
            <c>PCRE2_ERROR_UTF8_ERR9</c> - UTF-8 error: byte 5 top bits not 0x80.
            </summary>
        </member>
        <member name="F:PCRE.PcreErrorCode.Utf8Err10">
            <summary>
            <c>PCRE2_ERROR_UTF8_ERR10</c> - UTF-8 error: byte 6 top bits not 0x80.
            </summary>
        </member>
        <member name="F:PCRE.PcreErrorCode.Utf8Err11">
            <summary>
            <c>PCRE2_ERROR_UTF8_ERR11</c> - UTF-8 error: 5-byte character is not allowed (RFC 3629).
            </summary>
        </member>
        <member name="F:PCRE.PcreErrorCode.Utf8Err12">
            <summary>
            <c>PCRE2_ERROR_UTF8_ERR12</c> - UTF-8 error: 6-byte character is not allowed (RFC 3629).
            </summary>
        </member>
        <member name="F:PCRE.PcreErrorCode.Utf8Err13">
            <summary>
            <c>PCRE2_ERROR_UTF8_ERR13</c> - UTF-8 error: code points greater than 0x10ffff are not defined.
            </summary>
        </member>
        <member name="F:PCRE.PcreErrorCode.Utf8Err14">
            <summary>
            <c>PCRE2_ERROR_UTF8_ERR14</c> - UTF-8 error: code points 0xd800-0xdfff are not defined.
            </summary>
        </member>
        <member name="F:PCRE.PcreErrorCode.Utf8Err15">
            <summary>
            <c>PCRE2_ERROR_UTF8_ERR15</c> - UTF-8 error: overlong 2-byte sequence.
            </summary>
        </member>
        <member name="F:PCRE.PcreErrorCode.Utf8Err16">
            <summary>
            <c>PCRE2_ERROR_UTF8_ERR16</c> - UTF-8 error: overlong 3-byte sequence.
            </summary>
        </member>
        <member name="F:PCRE.PcreErrorCode.Utf8Err17">
            <summary>
            <c>PCRE2_ERROR_UTF8_ERR17</c> - UTF-8 error: overlong 4-byte sequence.
            </summary>
        </member>
        <member name="F:PCRE.PcreErrorCode.Utf8Err18">
            <summary>
            <c>PCRE2_ERROR_UTF8_ERR18</c> - UTF-8 error: overlong 5-byte sequence.
            </summary>
        </member>
        <member name="F:PCRE.PcreErrorCode.Utf8Err19">
            <summary>
            <c>PCRE2_ERROR_UTF8_ERR19</c> - UTF-8 error: overlong 6-byte sequence.
            </summary>
        </member>
        <member name="F:PCRE.PcreErrorCode.Utf8Err20">
            <summary>
            <c>PCRE2_ERROR_UTF8_ERR20</c> - UTF-8 error: isolated byte with 0x80 bit set.
            </summary>
        </member>
        <member name="F:PCRE.PcreErrorCode.Utf8Err21">
            <summary>
            <c>PCRE2_ERROR_UTF8_ERR21</c> - UTF-8 error: illegal byte (0xfe or 0xff).
            </summary>
        </member>
        <member name="F:PCRE.PcreErrorCode.Utf16Err1">
            <summary>
            <c>PCRE2_ERROR_UTF16_ERR1</c> - UTF-16 error: missing low surrogate at end.
            </summary>
        </member>
        <member name="F:PCRE.PcreErrorCode.Utf16Err2">
            <summary>
            <c>PCRE2_ERROR_UTF16_ERR2</c> - UTF-16 error: invalid low surrogate.
            </summary>
        </member>
        <member name="F:PCRE.PcreErrorCode.Utf16Err3">
            <summary>
            <c>PCRE2_ERROR_UTF16_ERR3</c> - UTF-16 error: isolated low surrogate.
            </summary>
        </member>
        <member name="F:PCRE.PcreErrorCode.Utf32Err1">
            <summary>
            <c>PCRE2_ERROR_UTF32_ERR1</c> - UTF-32 error: code points 0xd800-0xdfff are not defined.
            </summary>
        </member>
        <member name="F:PCRE.PcreErrorCode.Utf32Err2">
            <summary>
            <c>PCRE2_ERROR_UTF32_ERR2</c> - UTF-32 error: code points greater than 0x10ffff are not defined.
            </summary>
        </member>
        <member name="F:PCRE.PcreErrorCode.BadData">
            <summary>
            <c>PCRE2_ERROR_BADDATA</c> - Bad data value.
            </summary>
        </member>
        <member name="F:PCRE.PcreErrorCode.MixedTables">
            <summary>
            <c>PCRE2_ERROR_MIXEDTABLES</c> - Patterns do not all use the same character tables.
            </summary>
        </member>
        <member name="F:PCRE.PcreErrorCode.BadMagic">
            <summary>
            <c>PCRE2_ERROR_BADMAGIC</c> - Magic number missing.
            </summary>
        </member>
        <member name="F:PCRE.PcreErrorCode.BadMode">
            <summary>
            <c>PCRE2_ERROR_BADMODE</c> - Pattern compiled in wrong mode: 8/16/32-bit error.
            </summary>
        </member>
        <member name="F:PCRE.PcreErrorCode.BadOffset">
            <summary>
            <c>PCRE2_ERROR_BADOFFSET</c> - Bad offset value.
            </summary>
        </member>
        <member name="F:PCRE.PcreErrorCode.BadOption">
            <summary>
            <c>PCRE2_ERROR_BADOPTION</c> - Bad option value.
            </summary>
        </member>
        <member name="F:PCRE.PcreErrorCode.BadReplacement">
            <summary>
            <c>PCRE2_ERROR_BADREPLACEMENT</c> - Invalid replacement string.
            </summary>
        </member>
        <member name="F:PCRE.PcreErrorCode.BadUtfOffset">
            <summary>
            <c>PCRE2_ERROR_BADUTFOFFSET</c> - Bad offset into UTF string.
            </summary>
        </member>
        <member name="F:PCRE.PcreErrorCode.Callout">
            <summary>
            <c>PCRE2_ERROR_CALLOUT</c> - Callout error code.
            </summary>
        </member>
        <member name="F:PCRE.PcreErrorCode.DfaBadRestart">
            <summary>
            <c>PCRE2_ERROR_DFA_BADRESTART</c> - Invalid data in workspace for DFA restart.
            </summary>
        </member>
        <member name="F:PCRE.PcreErrorCode.DfaRecurse">
            <summary>
            <c>PCRE2_ERROR_DFA_RECURSE</c> - Too much recursion for DFA matching.
            </summary>
        </member>
        <member name="F:PCRE.PcreErrorCode.DfaUCond">
            <summary>
            <c>PCRE2_ERROR_DFA_UCOND</c> - Backreference condition or recursion test is not supported for DFA matching.
            </summary>
        </member>
        <member name="F:PCRE.PcreErrorCode.DfaUFunc">
            <summary>
            <c>PCRE2_ERROR_DFA_UFUNC</c> - Function is not supported for DFA matching.
            </summary>
        </member>
        <member name="F:PCRE.PcreErrorCode.DfaUItem">
            <summary>
            <c>PCRE2_ERROR_DFA_UITEM</c> - Pattern contains an item that is not supported for DFA matching.
            </summary>
        </member>
        <member name="F:PCRE.PcreErrorCode.DfaWsSize">
            <summary>
            <c>PCRE2_ERROR_DFA_WSSIZE</c> - Workspace size exceeded in DFA matching.
            </summary>
        </member>
        <member name="F:PCRE.PcreErrorCode.Internal">
            <summary>
            <c>PCRE2_ERROR_INTERNAL</c> - Internal error - pattern overwritten?
            </summary>
        </member>
        <member name="F:PCRE.PcreErrorCode.JitBadOption">
            <summary>
            <c>PCRE2_ERROR_JIT_BADOPTION</c> - Bad JIT option.
            </summary>
        </member>
        <member name="F:PCRE.PcreErrorCode.JitStackLimit">
            <summary>
            <c>PCRE2_ERROR_JIT_STACKLIMIT</c> - JIT stack limit reached.
            </summary>
        </member>
        <member name="F:PCRE.PcreErrorCode.MatchLimit">
            <summary>
            <c>PCRE2_ERROR_MATCHLIMIT</c> - Match limit exceeded.
            </summary>
        </member>
        <member name="F:PCRE.PcreErrorCode.NoMemory">
            <summary>
            <c>PCRE2_ERROR_NOMEMORY</c> - No more memory.
            </summary>
        </member>
        <member name="F:PCRE.PcreErrorCode.NoSubstring">
            <summary>
            <c>PCRE2_ERROR_NOSUBSTRING</c> - Unknown substring.
            </summary>
        </member>
        <member name="F:PCRE.PcreErrorCode.NoUniqueSubstring">
            <summary>
            <c>PCRE2_ERROR_NOUNIQUESUBSTRING</c> - Non-unique substring name.
            </summary>
        </member>
        <member name="F:PCRE.PcreErrorCode.Null">
            <summary>
            <c>PCRE2_ERROR_NULL</c> - NULL argument passed.
            </summary>
        </member>
        <member name="F:PCRE.PcreErrorCode.RecurseLoop">
            <summary>
            <c>PCRE2_ERROR_RECURSELOOP</c> - Nested recursion at the same subject position.
            </summary>
        </member>
        <member name="F:PCRE.PcreErrorCode.DepthLimit">
            <summary>
            <c>PCRE2_ERROR_DEPTHLIMIT</c> - Matching depth limit exceeded.
            </summary>
        </member>
        <member name="F:PCRE.PcreErrorCode.Unavailable">
            <summary>
            <c>PCRE2_ERROR_UNAVAILABLE</c> - Requested value is not available.
            </summary>
        </member>
        <member name="F:PCRE.PcreErrorCode.Unset">
            <summary>
            <c>PCRE2_ERROR_UNSET</c> - Requested value is not set.
            </summary>
        </member>
        <member name="F:PCRE.PcreErrorCode.BadOffsetLimit">
            <summary>
            <c>PCRE2_ERROR_BADOFFSETLIMIT</c> - Offset limit set without <see cref="F:PCRE.PcreOptions.UseOffsetLimit"/>
            </summary>
        </member>
        <member name="F:PCRE.PcreErrorCode.BadRepEscape">
            <summary>
            <c>PCRE2_ERROR_BADREPESCAPE</c> - Bad escape sequence in replacement string.
            </summary>
        </member>
        <member name="F:PCRE.PcreErrorCode.RepMissingBrace">
            <summary>
            <c>PCRE2_ERROR_REPMISSINGBRACE</c> - Expected closing curly bracket in replacement string.
            </summary>
        </member>
        <member name="F:PCRE.PcreErrorCode.BadSubstitution">
            <summary>
            <c>PCRE2_ERROR_BADSUBSTITUTION</c> - Bad substitution in replacement string.
            </summary>
        </member>
        <member name="F:PCRE.PcreErrorCode.BadSubsPattern">
            <summary>
            <c>PCRE2_ERROR_BADSUBSPATTERN</c> - Match with end before start or start moved backwards is not supported.
            </summary>
        </member>
        <member name="F:PCRE.PcreErrorCode.TooManyReplace">
            <summary>
            <c>PCRE2_ERROR_TOOMANYREPLACE</c> - Too many replacements (more than <see cref="F:System.Int32.MaxValue"/>)
            </summary>
        </member>
        <member name="F:PCRE.PcreErrorCode.BadSerializedData">
            <summary>
            <c>PCRE2_ERROR_BADSERIALIZEDDATA</c> - Bad serialized data.
            </summary>
        </member>
        <member name="F:PCRE.PcreErrorCode.HeapLimit">
            <summary>
            <c>PCRE2_ERROR_HEAPLIMIT</c> - Heap limit exceeded.
            </summary>
        </member>
        <member name="F:PCRE.PcreErrorCode.ConvertSyntax">
            <summary>
            <c>PCRE2_ERROR_CONVERT_SYNTAX</c> - Invalid syntax.
            </summary>
        </member>
        <member name="F:PCRE.PcreErrorCode.InternalDupMatch">
            <summary>
            <c>PCRE2_ERROR_INTERNAL_DUPMATCH</c> - Internal error - duplicate substitution match.
            </summary>
        </member>
        <member name="F:PCRE.PcreErrorCode.DfaUInvalidUtf">
            <summary>
            <c>PCRE2_ERROR_DFA_UINVALID_UTF</c> - <see cref="F:PCRE.PcreOptions.MatchInvalidUtf"/> is not supported for DFA matching.
            </summary>
        </member>
        <member name="F:PCRE.PcreErrorCode.InvalidOffset">
            <summary>
            <c>PCRE2_ERROR_INVALIDOFFSET</c> - Invalid offset value.
            </summary>
        </member>
        <member name="T:PCRE.PcreException">
            <summary>
            Represents errors returned by PCRE.
            </summary>
        </member>
        <member name="P:PCRE.PcreException.ErrorCode">
            <summary>
            The error code returned by PCRE.
            </summary>
        </member>
        <member name="M:PCRE.PcreException.#ctor(PCRE.PcreErrorCode)">
            <summary>
            Creates a <see cref="T:PCRE.PcreException"/>
            </summary>
            <param name="errorCode">The associated error code.</param>
        </member>
        <member name="M:PCRE.PcreException.#ctor(PCRE.PcreErrorCode,System.String)">
            <summary>
            Creates a <see cref="T:PCRE.PcreException"/>
            </summary>
            <param name="errorCode">The associated error code.</param>
            <param name="message">The exception message.</param>
        </member>
        <member name="M:PCRE.PcreException.#ctor(PCRE.PcreErrorCode,System.String,System.Exception)">
            <summary>
            Creates a <see cref="T:PCRE.PcreException"/>
            </summary>
            <param name="errorCode">The associated error code.</param>
            <param name="message">The exception message.</param>
            <param name="innerException">The inner exception.</param>
        </member>
        <member name="T:PCRE.PcrePatternException">
            <summary>
            Represents an error that occured during pattern compilation.
            </summary>
        </member>
        <member name="M:PCRE.PcrePatternException.#ctor(PCRE.PcreErrorCode,System.String)">
            <summary>
            Creates a <see cref="T:PCRE.PcrePatternException"/>
            </summary>
            <param name="errorCode">The associated error code.</param>
            <param name="message">The exception message.</param>
        </member>
        <member name="T:PCRE.PcreMatchException">
            <summary>
            Represents an error that occured during pattern matching.
            </summary>
        </member>
        <member name="M:PCRE.PcreMatchException.#ctor(PCRE.PcreErrorCode)">
            <summary>
            Creates a <see cref="T:PCRE.PcreMatchException"/>
            </summary>
            <param name="errorCode">The associated error code.</param>
        </member>
        <member name="M:PCRE.PcreMatchException.#ctor(PCRE.PcreErrorCode,System.String,System.Exception)">
            <summary>
            Creates a <see cref="T:PCRE.PcreMatchException"/>
            </summary>
            <param name="errorCode">The associated error code.</param>
            <param name="message">The exception message.</param>
            <param name="innerException">The inner exception.</param>
        </member>
        <member name="T:PCRE.PcreCalloutException">
            <summary>
            Represents an error that occured during the execution of a callout.
            </summary>
        </member>
        <member name="M:PCRE.PcreCalloutException.#ctor(System.String,System.Exception)">
            <summary>
            Creates a <see cref="T:PCRE.PcreCalloutException"/>
            </summary>
            <param name="message">The exception message.</param>
            <param name="innerException">The inner exception.</param>
        </member>
        <member name="T:PCRE.PcreExtraCompileOptions">
            <summary>
            Extra pattern compile options.
            </summary>
        </member>
        <member name="F:PCRE.PcreExtraCompileOptions.None">
            <summary>
            No additional options.
            </summary>
        </member>
        <member name="F:PCRE.PcreExtraCompileOptions.BadEscapeIsLiteral">
            <summary>
            <c>PCRE2_EXTRA_BAD_ESCAPE_IS_LITERAL</c> - Treat unrecognized escapes as literals.
            </summary>
            <remarks>
            <para>
            This is a dangerous option. Use with care. By default, an unrecognized escape such as <c>\j</c> or a malformed one such as <c>\x{2z}</c> causes a compile-time error
            when detected by <c>pcre2_compile()</c>.
            </para>
            <para>
            Perl is somewhat inconsistent in handling such items: for example, <c>\j</c> is treated as a literal "j",
            and non-hexadecimal digits in <c>\x{}</c> are just ignored, though warnings are given in both cases if Perl's warning switch is enabled.
            However, a malformed octal number after <c>\o{</c> always causes an error in Perl.
            </para>
            <para>
            If the <see cref="F:PCRE.PcreExtraCompileOptions.BadEscapeIsLiteral"/> extra option is passed to <c>pcre2_compile()</c>, all unrecognized or malformed escape sequences are treated as single-character escapes.
            For example, <c>\j</c> is a literal "j" and <c>\x{2z}</c> is treated as the literal string "x{2z}".
            </para>
            <para>
            Setting this option means that typos in patterns may go undetected and have unexpected results.
            Also note that a sequence such as <c>[\N{]</c> is interpreted as a malformed attempt at <c>[\N{...}]</c> and so is treated as <c>[N{]</c> whereas <c>[\N]</c> gives an error
            because an unqualified <c>\N</c> is a valid escape sequence but is not supported in a character class.
            </para>
            <para>
            To reiterate: this is a dangerous option. Use with great care.
            </para>
            </remarks>
        </member>
        <member name="F:PCRE.PcreExtraCompileOptions.MatchWord">
            <summary>
            <c>PCRE2_EXTRA_MATCH_WORD</c> - Require word boundaries at the start and end of a match.
            </summary>
            <remarks>
            This option is provided for use by the <c>-w</c> option of pcre2grep.
            It causes the pattern only to match strings that have a word boundary at the start and the end.
            This is achieved by automatically inserting the code for "<c>\b(?:</c>" at the start of the compiled pattern and "<c>)\b</c>" at the end.
            The option may be used with <see cref="F:PCRE.PcreOptions.Literal"/>. However, it is ignored if <see cref="F:PCRE.PcreExtraCompileOptions.MatchLine"/> is also set.
            </remarks>
        </member>
        <member name="F:PCRE.PcreExtraCompileOptions.MatchLine">
            <summary>
            <c>PCRE2_EXTRA_MATCH_LINE</c> - Require the pattern to match complete lines.
            </summary>
            <remarks>
            This option is provided for use by the <c>-x</c> option of pcre2grep. It causes the pattern only to match complete lines.
            This is achieved by automatically inserting the code for "<c>^(?:</c>" at the start of the compiled pattern and "<c>)$</c>" at the end.
            Thus, when <see cref="F:PCRE.PcreOptions.MultiLine"/> is set, the matched line may be in the middle of the subject string. This option can be used with <see cref="F:PCRE.PcreOptions.Literal"/>.
            </remarks>
        </member>
        <member name="F:PCRE.PcreExtraCompileOptions.EscapedCrIsLf">
            <summary>
            <c>PCRE2_EXTRA_ESCAPED_CR_IS_LF</c> - Treat <c>\r</c> as <c>\n</c>.
            </summary>
            <remarks>
            <para>
            There are some legacy applications where the escape sequence <c>\r</c> in a pattern is expected to match a newline.
            If this option is set, <c>\r</c> in a pattern is converted to <c>\n</c> so that it matches a LF (linefeed) instead of a CR (carriage return) character.
            </para>
            <para>
            The option does not affect a literal CR in the pattern, nor does it affect CR specified as an explicit code point such as <c>\x{0D}</c>.
            </para>
            </remarks>
        </member>
        <member name="F:PCRE.PcreExtraCompileOptions.AltBsUX">
            <summary>
            <c>PCRE2_EXTRA_ALT_BSUX</c> - Alternative handling of some escape sequences (ECMAScript 6 compliant behavior).
            </summary>
            <remarks>
            The original option <see cref="F:PCRE.PcreOptions.AltBsUX"/> causes PCRE2 to process <c>\U</c>, <c>\u</c>, and <c>\x</c> in the way that ECMAscript (aka JavaScript) does.
            Additional functionality was defined by ECMAscript 6; setting <see cref="F:PCRE.PcreExtraCompileOptions.AltBsUX"/> has the effect of <see cref="F:PCRE.PcreOptions.AltBsUX"/>, but in addition it recognizes <c>\u{hhh..}</c>
            as a hexadecimal character code, where <c>hhh..</c> is any number of hexadecimal digits.
            </remarks>
        </member>
        <member name="F:PCRE.PcreExtraCompileOptions.AllowLookaroundBsK">
            <summary>
            <c>PCRE2_EXTRA_ALLOW_LOOKAROUND_BSK</c> - Allow <c>\K</c> in lookarounds.
            </summary>
            <remarks>
            Since release 10.38 PCRE2 has forbidden the use of <c>\K</c> within lookaround assertions, following Perl's lead.
            This option is provided to re-enable the previous behaviour (act in positive lookarounds, ignore in negative ones) in case anybody is relying on it.
            </remarks>
        </member>
        <member name="F:PCRE.PcreExtraCompileOptions.CaselessRestrict">
            <summary>
            <c>PCRE2_EXTRA_CASELESS_RESTRICT</c> - Disable mixed ASCII/non-ASCII case folding.
            </summary>
            <remarks>
            <para>
            When either <see cref="F:PCRE.PcreOptions.Ucp"/> or <see cref="F:PCRE.PcreOptions.Utf"/> is set, caseless matching follows Unicode rules, which allow for more than two cases per character.
            There are two case-equivalent character sets that contain both ASCII and non-ASCII characters.
            The ASCII letter S is case-equivalent to U+017f (long S) and the ASCII letter K is case-equivalent to U+212a (Kelvin sign).
            This option disables recognition of case-equivalences that cross the ASCII/non-ASCII boundary.
            In a caseless match, both characters must either be ASCII or non-ASCII.
            </para>
            <para>
            The option can be changed with a pattern by the <c>(?r)</c> option setting.
            </para>
            </remarks>
        </member>
        <member name="F:PCRE.PcreExtraCompileOptions.AsciiBsD">
            <summary>
            <c>PCRE2_EXTRA_ASCII_BSD</c> - Forces <c>\d</c> to match only ASCII digits, even when <see cref="F:PCRE.PcreOptions.Ucp"/> is set.
            </summary>
            <remarks>
            It can also be changed within a pattern by means of the <c>(?aD)</c> option setting.
            </remarks>
        </member>
        <member name="F:PCRE.PcreExtraCompileOptions.AsciiBsS">
            <summary>
            <c>PCRE2_EXTRA_ASCII_BSS</c> - Forces <c>\s</c> to match only ASCII digits, even when <see cref="F:PCRE.PcreOptions.Ucp"/> is set.
            </summary>
            <remarks>
            It can also be changed within a pattern by means of the <c>(?aS)</c> option setting.
            </remarks>
        </member>
        <member name="F:PCRE.PcreExtraCompileOptions.AsciiBsW">
            <summary>
            <c>PCRE2_EXTRA_ASCII_BSW</c> - Forces <c>\w</c> to match only ASCII digits, even when <see cref="F:PCRE.PcreOptions.Ucp"/> is set.
            </summary>
            <remarks>
            It can also be changed within a pattern by means of the <c>(?aW)</c> option setting.
            </remarks>
        </member>
        <member name="F:PCRE.PcreExtraCompileOptions.AsciiPosix">
            <summary>
            <c>PCRE2_EXTRA_ASCII_POSIX</c> - Forces all the POSIX character classes, including <c>[:digit:]</c> and <c>[:xdigit:]</c>, to match only ASCII characters, even when <see cref="F:PCRE.PcreOptions.Ucp"/> is set.
            </summary>
            <remarks>
            It can be changed within a pattern by means of the <c>(?aP)</c> option setting, but note that this also sets <see cref="F:PCRE.PcreExtraCompileOptions.AsciiDigit"/> in order to ensure that <c>(?-aP)</c> unsets all ASCII restrictions for POSIX classes.
            </remarks>
        </member>
        <member name="F:PCRE.PcreExtraCompileOptions.AsciiDigit">
            <summary>
            <c>PCRE2_EXTRA_ASCII_DIGIT</c> - Forces the POSIX character classes <c>[:digit:]</c> and <c>[:xdigit:]</c> to match only ASCII digits, even when <see cref="F:PCRE.PcreOptions.Ucp"/> is set.
            </summary>
            <remarks>
            It can be changed within a pattern by means of the <c>(?aT)</c> option setting.
            </remarks>
        </member>
        <member name="F:PCRE.PcreExtraCompileOptions.AllowSurrogateEscapes">
            <summary>
            <c>PCRE2_EXTRA_ALLOW_SURROGATE_ESCAPES</c> - Allow surrogate escapes in UTF-8 and UTF-32.
            </summary>
            <remarks>
            <para>
            This option applies when compiling a pattern in UTF-8 or UTF-32 mode. It is forbidden in UTF-16 mode, and ignored in non-UTF modes.
            Unicode "surrogate" code points in the range 0xd800 to 0xdfff are used in pairs in UTF-16 to encode code points with values in the range 0x10000 to 0x10ffff.
            The surrogates cannot therefore be represented in UTF-16. They can be represented in UTF-8 and UTF-32, but are defined as invalid code points, and cause errors
            if encountered in a UTF-8 or UTF-32 string that is being checked for validity by PCRE2.
            </para>
            <para>
            These values also cause errors if encountered in escape sequences such as <c>\x{d912}</c> within a pattern.
            However, it seems that some applications, when using PCRE2 to check for unwanted characters in UTF-8 strings, explicitly test for the surrogates using escape sequences.
            The <see cref="F:PCRE.PcreOptions.NoUtfCheck"/> option does not disable the error that occurs, because it applies only to the testing of input strings for UTF validity.
            </para>
            <para>
            If the extra option <see cref="F:PCRE.PcreExtraCompileOptions.AllowSurrogateEscapes"/> is set, surrogate code point values in UTF-8 and UTF-32 patterns no longer provoke errors and are incorporated in the compiled pattern.
            However, they can only match subject characters if the matching function is called with <see cref="F:PCRE.PcreOptions.NoUtfCheck"/> set.
            </para>
            </remarks>
        </member>
        <member name="T:PCRE.PcreGroup">
            <summary>
            The result of a capturing group.
            </summary>
        </member>
        <member name="P:PCRE.PcreGroup.Index">
            <inheritdoc/>
        </member>
        <member name="P:PCRE.PcreGroup.EndIndex">
            <inheritdoc/>
        </member>
        <member name="P:PCRE.PcreGroup.Length">
            <inheritdoc/>
        </member>
        <member name="P:PCRE.PcreGroup.Value">
            <inheritdoc/>
        </member>
        <member name="P:PCRE.PcreGroup.ValueSpan">
            <inheritdoc/>
        </member>
        <member name="P:PCRE.PcreGroup.Success">
            <inheritdoc/>
        </member>
        <member name="P:PCRE.PcreGroup.IsDefined">
            <summary>
            Indicates if the group exists in the pattern.
            </summary>
        </member>
        <member name="M:PCRE.PcreGroup.op_Implicit(PCRE.PcreGroup)~System.String">
            <summary>
            Converts a group to its matched substring.
            </summary>
        </member>
        <member name="M:PCRE.PcreGroup.ToString">
            <summary>
            Returns the matched substring.
            </summary>
        </member>
        <member name="T:PCRE.PcreJitCompileOptions">
            <summary>
            Additional options for the JIT compiler.
            </summary>
        </member>
        <member name="F:PCRE.PcreJitCompileOptions.None">
            <summary>
            No additional options.
            </summary>
        </member>
        <member name="F:PCRE.PcreJitCompileOptions.Complete">
            <summary>
            <c>PCRE2_JIT_COMPLETE</c> - Compile code for full matching.
            </summary>
        </member>
        <member name="F:PCRE.PcreJitCompileOptions.PartialSoft">
            <summary>
            <c>PCRE2_JIT_PARTIAL_SOFT</c> - Compile code for soft partial matching.
            </summary>
            <see cref="F:PCRE.PcreMatchOptions.PartialSoft"/>
        </member>
        <member name="F:PCRE.PcreJitCompileOptions.PartialHard">
            <summary>
            <c>PCRE2_JIT_PARTIAL_HARD</c> - Compile code for hard partial matching
            </summary>
            <see cref="F:PCRE.PcreMatchOptions.PartialHard"/>
        </member>
        <member name="T:PCRE.PcreJitStack">
            <summary>
            JIT stack for advanced usage scenarios.
            </summary>
            <remarks>
            <para>
            Not thread-safe and not reentrant.
            </para>
            <para>
            When the compiled JIT code runs, it needs a block of memory to use as a stack. By default, it uses 32KiB on the machine stack.
            However, some large or complicated patterns need more than this. The error <see cref="F:PCRE.PcreErrorCode.JitStackLimit"/> is given when there is not enough stack.
            </para>
            <para>
            You may safely use the same JIT stack for more than one pattern (either by assigning directly or by callback), as long as the patterns are matched sequentially in the same thread.
            Currently, the only way to set up non-sequential matches in one thread is to use callouts: if a callout function starts another match,
            that match must use a different JIT stack to the one used for currently suspended match(es).
            </para>
            </remarks>
        </member>
        <member name="M:PCRE.PcreJitStack.#ctor(System.UInt32,System.UInt32)">
            <summary>
            Creates a JIT stack.
            </summary>
            <param name="startSize">The initial stack size.</param>
            <param name="maxSize">The maximum stack size.</param>
        </member>
        <member name="M:PCRE.PcreJitStack.Finalize">
            <summary>
            Releases the JIT stack.
            </summary>
        </member>
        <member name="M:PCRE.PcreJitStack.Dispose">
            <summary>
            Disposes the JIT stack.
            </summary>
        </member>
        <member name="T:PCRE.PcreMatch">
            <summary>
            The result of a match.
            </summary>
        </member>
        <member name="P:PCRE.PcreMatch.CaptureCount">
            <summary>
            The number of captured groups.
            </summary>
        </member>
        <member name="P:PCRE.PcreMatch.Item(System.Int32)">
            <summary>
            Returns the capturing group at a given index.
            </summary>
            <param name="index">The index of the capturing group.</param>
        </member>
        <member name="P:PCRE.PcreMatch.Item(System.String)">
            <summary>
            Returns the capturing group of a given name.
            </summary>
            <param name="name">The name of the capturing group.</param>
        </member>
        <member name="P:PCRE.PcreMatch.Index">
            <summary>
            The start index of the match.
            </summary>
        </member>
        <member name="P:PCRE.PcreMatch.EndIndex">
            <summary>
            The end index of the match.
            </summary>
        </member>
        <member name="P:PCRE.PcreMatch.Length">
            <summary>
            The length of the match.
            </summary>
        </member>
        <member name="P:PCRE.PcreMatch.Value">
            <summary>
            The matched substring.
            </summary>
        </member>
        <member name="P:PCRE.PcreMatch.ValueSpan">
            <summary>
            The matched substring, as a <see cref="T:System.ReadOnlySpan`1"/>.
            </summary>
        </member>
        <member name="P:PCRE.PcreMatch.Success">
            <summary>
            Indicates if the match was successful.
            </summary>
        </member>
        <member name="P:PCRE.PcreMatch.Mark">
            <summary>
            Returns the last mark name encountered on the matching path through the pattern.
            </summary>
            <remarks>
            Marks are defined with <c>(*MARK)</c>.
            </remarks>
        </member>
        <member name="P:PCRE.PcreMatch.Groups">
            <summary>
            Returns the list of capturing groups.
            </summary>
        </member>
        <member name="P:PCRE.PcreMatch.IsPartialMatch">
            <summary>
            Indicates if the match is partial. See <see cref="F:PCRE.PcreMatchOptions.PartialSoft"/>/<see cref="F:PCRE.PcreMatchOptions.PartialHard"/>.
            </summary>
        </member>
        <member name="M:PCRE.PcreMatch.GetEnumerator">
            <summary>
            Returns an enumerator through the capturing groups.
            </summary>
        </member>
        <member name="M:PCRE.PcreMatch.TryGetGroup(System.Int32,PCRE.PcreGroup@)">
            <summary>
            Tries to get a group by index.
            </summary>
            <param name="index">The index of the group to retrieve.</param>
            <param name="result">The resulting group.</param>
            <returns>True if the group exists.</returns>
        </member>
        <member name="M:PCRE.PcreMatch.TryGetGroup(System.String,PCRE.PcreGroup@)">
            <summary>
            Tries to get a group by name.
            </summary>
            <param name="name">The name of the group to retrieve.</param>
            <param name="result">The resulting group.</param>
            <returns>True if the group exists.</returns>
        </member>
        <member name="M:PCRE.PcreMatch.GetDuplicateNamedGroups(System.String)">
            <summary>
            Gets the groups with duplicated names.
            </summary>
            <param name="name">The group name to retrieve.</param>
        </member>
        <member name="M:PCRE.PcreMatch.ToString">
            <summary>
            Returns the matched substring.
            </summary>
        </member>
        <member name="T:PCRE.PcreMatchBuffer">
            <summary>
            A buffer that allows execution of regular expression matches without managed allocations.
            </summary>
            <remarks>
            Not thread-safe and not reentrant.
            </remarks>
        </member>
        <member name="M:PCRE.PcreMatchBuffer.Finalize">
            <inheritdoc />
        </member>
        <member name="M:PCRE.PcreMatchBuffer.Dispose">
            <inheritdoc />
        </member>
        <member name="M:PCRE.PcreMatchBuffer.IsMatch(System.ReadOnlySpan{System.Char})">
            <summary>
      Indicates whether the regex matches the given subject.
    </summary>
            <param name="subject">The subject string to be matched.</param>
        </member>
        <member name="M:PCRE.PcreMatchBuffer.IsMatch(System.ReadOnlySpan{System.Char},System.Int32)">
            <summary>
      Indicates whether the regex matches the given subject.
    </summary>
            <param name="subject">The subject string to be matched.</param><param name="startIndex">The index at which the match should be attempted.</param>
            <remarks>
            <para>
      Passing a non-zero
      <paramref name="startIndex" />
      differs from passing a shortened string if the pattern
      starts with an assertion (such as <c>\b</c>) or contains lookbehinds.
    </para>
            </remarks>
        </member>
        <member name="M:PCRE.PcreMatchBuffer.Match(System.ReadOnlySpan{System.Char})">
            <summary>
      Matches the regex against the given subject.
    </summary>
            <param name="subject">The subject string to be matched.</param>
        </member>
        <member name="M:PCRE.PcreMatchBuffer.Match(System.ReadOnlySpan{System.Char},PCRE.PcreMatchOptions)">
            <summary>
      Matches the regex against the given subject.
    </summary>
            <param name="subject">The subject string to be matched.</param><param name="options">Additional options.</param>
        </member>
        <member name="M:PCRE.PcreMatchBuffer.Match(System.ReadOnlySpan{System.Char},System.Int32)">
            <summary>
      Matches the regex against the given subject.
    </summary>
            <param name="subject">The subject string to be matched.</param><param name="startIndex">The index at which the match should be attempted.</param>
            <remarks>
            <para>
      Passing a non-zero
      <paramref name="startIndex" />
      differs from passing a shortened string if the pattern
      starts with an assertion (such as <c>\b</c>) or contains lookbehinds.
    </para>
            </remarks>
        </member>
        <member name="M:PCRE.PcreMatchBuffer.Match(System.ReadOnlySpan{System.Char},System.Int32,PCRE.PcreMatchOptions)">
            <summary>
      Matches the regex against the given subject.
    </summary>
            <param name="subject">The subject string to be matched.</param><param name="startIndex">The index at which the match should be attempted.</param><param name="options">Additional options.</param>
            <remarks>
            <para>
      Passing a non-zero
      <paramref name="startIndex" />
      differs from passing a shortened string if the pattern
      starts with an assertion (such as <c>\b</c>) or contains lookbehinds.
    </para>
            </remarks>
        </member>
        <member name="M:PCRE.PcreMatchBuffer.Match(System.ReadOnlySpan{System.Char},PCRE.PcreRefCalloutFunc)">
            <summary>
      Matches the regex against the given subject.
    </summary>
            <param name="subject">The subject string to be matched.</param><param name="onCallout">A function to be called when a callout point is reached during the match.</param>
            <remarks>
            <para>
      Within a regular expression, <c>(?C&lt;arg&gt;)</c> indicates a point at which the external function is to be called.
      Different callout points can be identified by putting a number less than 256 after the letter C. The default value is zero.
      Alternatively, the argument may be a delimited string. The starting delimiter must be one of
      <c>` ' " ^ % # $ {</c>
      and the ending delimiter is the same as the start, except for <c>{</c>, where the ending delimiter is <c>}</c>.
      If the
      <see cref="F:PCRE.PcreOptions.AutoCallout" />
      option bit is set when a pattern is compiled, PCRE2 automatically inserts callouts,
      all with number 255, before each item in the pattern except for immediately before or after an explicit callout.
    </para>
            </remarks>
        </member>
        <member name="M:PCRE.PcreMatchBuffer.Match(System.ReadOnlySpan{System.Char},PCRE.PcreMatchOptions,PCRE.PcreRefCalloutFunc)">
            <summary>
      Matches the regex against the given subject.
    </summary>
            <param name="subject">The subject string to be matched.</param><param name="options">Additional options.</param><param name="onCallout">A function to be called when a callout point is reached during the match.</param>
            <remarks>
            <para>
      Within a regular expression, <c>(?C&lt;arg&gt;)</c> indicates a point at which the external function is to be called.
      Different callout points can be identified by putting a number less than 256 after the letter C. The default value is zero.
      Alternatively, the argument may be a delimited string. The starting delimiter must be one of
      <c>` ' " ^ % # $ {</c>
      and the ending delimiter is the same as the start, except for <c>{</c>, where the ending delimiter is <c>}</c>.
      If the
      <see cref="F:PCRE.PcreOptions.AutoCallout" />
      option bit is set when a pattern is compiled, PCRE2 automatically inserts callouts,
      all with number 255, before each item in the pattern except for immediately before or after an explicit callout.
    </para>
            </remarks>
        </member>
        <member name="M:PCRE.PcreMatchBuffer.Match(System.ReadOnlySpan{System.Char},System.Int32,PCRE.PcreRefCalloutFunc)">
            <summary>
      Matches the regex against the given subject.
    </summary>
            <param name="subject">The subject string to be matched.</param><param name="startIndex">The index at which the match should be attempted.</param><param name="onCallout">A function to be called when a callout point is reached during the match.</param>
            <remarks>
            <para>
      Within a regular expression, <c>(?C&lt;arg&gt;)</c> indicates a point at which the external function is to be called.
      Different callout points can be identified by putting a number less than 256 after the letter C. The default value is zero.
      Alternatively, the argument may be a delimited string. The starting delimiter must be one of
      <c>` ' " ^ % # $ {</c>
      and the ending delimiter is the same as the start, except for <c>{</c>, where the ending delimiter is <c>}</c>.
      If the
      <see cref="F:PCRE.PcreOptions.AutoCallout" />
      option bit is set when a pattern is compiled, PCRE2 automatically inserts callouts,
      all with number 255, before each item in the pattern except for immediately before or after an explicit callout.
    </para><para>
      Passing a non-zero
      <paramref name="startIndex" />
      differs from passing a shortened string if the pattern
      starts with an assertion (such as <c>\b</c>) or contains lookbehinds.
    </para>
            </remarks>
        </member>
        <member name="M:PCRE.PcreMatchBuffer.Match(System.ReadOnlySpan{System.Char},System.Int32,PCRE.PcreMatchOptions,PCRE.PcreRefCalloutFunc)">
            <summary>
      Matches the regex against the given subject.
    </summary>
            <param name="subject">The subject string to be matched.</param><param name="startIndex">The index at which the match should be attempted.</param><param name="options">Additional options.</param><param name="onCallout">A function to be called when a callout point is reached during the match.</param>
            <remarks>
            <para>
      Within a regular expression, <c>(?C&lt;arg&gt;)</c> indicates a point at which the external function is to be called.
      Different callout points can be identified by putting a number less than 256 after the letter C. The default value is zero.
      Alternatively, the argument may be a delimited string. The starting delimiter must be one of
      <c>` ' " ^ % # $ {</c>
      and the ending delimiter is the same as the start, except for <c>{</c>, where the ending delimiter is <c>}</c>.
      If the
      <see cref="F:PCRE.PcreOptions.AutoCallout" />
      option bit is set when a pattern is compiled, PCRE2 automatically inserts callouts,
      all with number 255, before each item in the pattern except for immediately before or after an explicit callout.
    </para><para>
      Passing a non-zero
      <paramref name="startIndex" />
      differs from passing a shortened string if the pattern
      starts with an assertion (such as <c>\b</c>) or contains lookbehinds.
    </para>
            </remarks>
        </member>
        <member name="M:PCRE.PcreMatchBuffer.Matches(System.ReadOnlySpan{System.Char})">
            <summary>
      Returns an enumerable of all matches found in the given subject.
    </summary>
            <param name="subject">The subject string to be matched.</param>
        </member>
        <member name="M:PCRE.PcreMatchBuffer.Matches(System.ReadOnlySpan{System.Char},System.Int32)">
            <summary>
      Returns an enumerable of all matches found in the given subject.
    </summary>
            <param name="subject">The subject string to be matched.</param><param name="startIndex">The index at which the match should be attempted.</param>
            <remarks>
            <para>
      Passing a non-zero
      <paramref name="startIndex" />
      differs from passing a shortened string if the pattern
      starts with an assertion (such as <c>\b</c>) or contains lookbehinds.
    </para>
            </remarks>
        </member>
        <member name="M:PCRE.PcreMatchBuffer.Matches(System.ReadOnlySpan{System.Char},System.Int32,PCRE.PcreRefCalloutFunc)">
            <summary>
      Returns an enumerable of all matches found in the given subject.
    </summary>
            <param name="subject">The subject string to be matched.</param><param name="startIndex">The index at which the match should be attempted.</param><param name="onCallout">A function to be called when a callout point is reached during the match.</param>
            <remarks>
            <para>
      Within a regular expression, <c>(?C&lt;arg&gt;)</c> indicates a point at which the external function is to be called.
      Different callout points can be identified by putting a number less than 256 after the letter C. The default value is zero.
      Alternatively, the argument may be a delimited string. The starting delimiter must be one of
      <c>` ' " ^ % # $ {</c>
      and the ending delimiter is the same as the start, except for <c>{</c>, where the ending delimiter is <c>}</c>.
      If the
      <see cref="F:PCRE.PcreOptions.AutoCallout" />
      option bit is set when a pattern is compiled, PCRE2 automatically inserts callouts,
      all with number 255, before each item in the pattern except for immediately before or after an explicit callout.
    </para><para>
      Passing a non-zero
      <paramref name="startIndex" />
      differs from passing a shortened string if the pattern
      starts with an assertion (such as <c>\b</c>) or contains lookbehinds.
    </para>
            </remarks>
        </member>
        <member name="M:PCRE.PcreMatchBuffer.Matches(System.ReadOnlySpan{System.Char},System.Int32,PCRE.PcreMatchOptions,PCRE.PcreRefCalloutFunc)">
            <summary>
      Returns an enumerable of all matches found in the given subject.
    </summary>
            <param name="subject">The subject string to be matched.</param><param name="startIndex">The index at which the match should be attempted.</param><param name="options">Additional options.</param><param name="onCallout">A function to be called when a callout point is reached during the match.</param>
            <remarks>
            <para>
      Within a regular expression, <c>(?C&lt;arg&gt;)</c> indicates a point at which the external function is to be called.
      Different callout points can be identified by putting a number less than 256 after the letter C. The default value is zero.
      Alternatively, the argument may be a delimited string. The starting delimiter must be one of
      <c>` ' " ^ % # $ {</c>
      and the ending delimiter is the same as the start, except for <c>{</c>, where the ending delimiter is <c>}</c>.
      If the
      <see cref="F:PCRE.PcreOptions.AutoCallout" />
      option bit is set when a pattern is compiled, PCRE2 automatically inserts callouts,
      all with number 255, before each item in the pattern except for immediately before or after an explicit callout.
    </para><para>
      Passing a non-zero
      <paramref name="startIndex" />
      differs from passing a shortened string if the pattern
      starts with an assertion (such as <c>\b</c>) or contains lookbehinds.
    </para>
            </remarks>
        </member>
        <member name="M:PCRE.PcreMatchBuffer.ToString">
            <summary>
            Returns the regex pattern.
            </summary>
        </member>
        <member name="T:PCRE.PcreMatchBuffer.RefMatchEnumerable">
            <summary>
            An enumerable of matches.
            </summary>
        </member>
        <member name="M:PCRE.PcreMatchBuffer.RefMatchEnumerable.GetEnumerator">
            <inheritdoc cref="M:System.Collections.Generic.IEnumerable`1.GetEnumerator"/>
        </member>
        <member name="T:PCRE.PcreMatchBuffer.RefMatchEnumerator">
            <summary>
            An enumerator of matches.
            </summary>
        </member>
        <member name="P:PCRE.PcreMatchBuffer.RefMatchEnumerator.Current">
            <summary>
            Gets the current match.
            </summary>
        </member>
        <member name="M:PCRE.PcreMatchBuffer.RefMatchEnumerator.MoveNext">
            <summary>
            Moves to the next match.
            </summary>
        </member>
        <member name="T:PCRE.PcreMatchOptions">
            <summary>
            Options for NFA matching.
            </summary>
        </member>
        <member name="F:PCRE.PcreMatchOptions.None">
            <summary>
            No additional options.
            </summary>
        </member>
        <member name="F:PCRE.PcreMatchOptions.Anchored">
            <summary>
            <c>PCRE2_ANCHORED</c> - Make the start of the pattern anchored, so it can only match at the starting position.
            </summary>
            <remarks>
            <para>
            The <see cref="F:PCRE.PcreMatchOptions.Anchored"/> option limits <c>pcre2_match()</c> to matching at the first matching position.
            If a pattern was compiled with <see cref="F:PCRE.PcreOptions.Anchored"/>, or turned out to be anchored by virtue of its contents, it cannot be made unachored at matching time.
            </para>
            <para>
            Note that setting the option at match time disables JIT matching.
            </para>
            </remarks>
            <seealso cref="F:PCRE.PcreOptions.Anchored"/>
        </member>
        <member name="F:PCRE.PcreMatchOptions.EndAnchored">
            <summary>
            <c>PCRE2_ENDANCHORED</c> - Make the end of the pattern anchored, so it needs to match until the end of the subject string.
            </summary>
            <remarks>
            <para>
            If the <see cref="F:PCRE.PcreMatchOptions.EndAnchored"/> option is set, any string that <c>pcre2_match()</c> matches must be right at the end of the subject string.
            </para>
            <para>
            Note that setting the option at match time disables JIT matching.
            </para>
            </remarks>
            <seealso cref="F:PCRE.PcreOptions.EndAnchored"/>
        </member>
        <member name="F:PCRE.PcreMatchOptions.NotBol">
            <summary>
            <c>PCRE2_NOTBOL</c> - Don't treat the first character of the subject string as a beginning of line.
            </summary>
            <remarks>
            <para>
            This option specifies that first character of the subject string is not the beginning of a line, so the circumflex metacharacter should not match before it.
            </para>
            <para>
            Setting this without having set <see cref="F:PCRE.PcreOptions.MultiLine"/> at compile time causes circumflex never to match.
            This option affects only the behaviour of the circumflex metacharacter. It does not affect <c>\A</c>.
            </para>
            </remarks>
        </member>
        <member name="F:PCRE.PcreMatchOptions.NotEol">
            <summary>
            <c>PCRE2_NOTEOL</c> - Don't treat the last character of the subject string as an end of line.
            </summary>
            <remarks>
            <para>
            This option specifies that the end of the subject string is not the end of a line, so the dollar metacharacter should not match it nor (except in multiline mode) a newline immediately before it.
            </para>
            <para>
            Setting this without having set <see cref="F:PCRE.PcreOptions.MultiLine"/> at compile time causes dollar never to match.
            This option affects only the behaviour of the dollar metacharacter. It does not affect <c>\Z</c> or <c>\z</c>.
            </para>
            </remarks>
        </member>
        <member name="F:PCRE.PcreMatchOptions.NotEmpty">
            <summary>
            <c>PCRE2_NOTEMPTY</c> - Don't consider the empty string as a valid match.
            </summary>
            <remarks>
            <para>
            An empty string is not considered to be a valid match if this option is set. If there are alternatives in the pattern, they are tried.
            If all the alternatives match the empty string, the entire match fails.
            </para>
            <para>
            For example, if the pattern <c>a?b?</c> is applied to a string not beginning with "a" or "b", it matches an empty string at the start of the subject.
            With <see cref="F:PCRE.PcreMatchOptions.NotEmpty"/> set, this match is not valid, so <c>pcre2_match()</c> searches further into the string for occurrences of "a" or "b".
            </para>
            </remarks>
        </member>
        <member name="F:PCRE.PcreMatchOptions.NotEmptyAtStart">
            <summary>
            <c>PCRE2_NOTEMPTY_ATSTART</c> - Don't consider the empty string at the starting position as a valid match.
            </summary>
            <remarks>
            This is like <see cref="F:PCRE.PcreMatchOptions.NotEmpty"/>, except that it locks out an empty string match only at the first matching position, that is, at the start of the subject plus the starting offset.
            An empty string match later in the subject is permitted. If the pattern is anchored, such a match can occur only if the pattern contains <c>\K</c>.
            </remarks>
        </member>
        <member name="F:PCRE.PcreMatchOptions.PartialSoft">
            <summary>
            <c>PCRE2_PARTIAL_SOFT</c> - Enable partial matching mode. Still try to find a complete match if a partial match is found first.
            </summary>
            <remarks>
            <para>
            A partial match occurs if the end of the subject string is reached successfully, but there are not enough subject characters to complete the match.
            In addition, either at least one character must have been inspected or the pattern must contain a lookbehind, or the pattern must be one that could match an empty string.
            </para>
            <para>
            If this situation arises when <see cref="F:PCRE.PcreMatchOptions.PartialSoft"/> (but not <see cref="F:PCRE.PcreMatchOptions.PartialHard"/>) is set, matching continues by testing any remaining alternatives.
            Only if no complete match can be found is <see cref="F:PCRE.PcreErrorCode.Partial"/> returned instead of <see cref="F:PCRE.PcreErrorCode.NoMatch"/>.
            In other words, <see cref="F:PCRE.PcreMatchOptions.PartialSoft"/> specifies that the caller is prepared to handle a partial match, but only if no complete match can be found.
            </para>
            <para>
            If <see cref="F:PCRE.PcreMatchOptions.PartialHard"/> is set, it overrides <see cref="F:PCRE.PcreMatchOptions.PartialSoft"/>. In this case, if a partial match is found, <c>pcre2_match()</c> immediately returns <see cref="F:PCRE.PcreErrorCode.Partial"/>,
            without considering any other alternatives. In other words, when <see cref="F:PCRE.PcreMatchOptions.PartialHard"/> is set, a partial match is considered to be more important that an alternative complete match.
            </para>
            <para>
            There is a more detailed discussion of partial and multi-segment matching, with examples, in the pcre2partial documentation.
            </para>
            </remarks>
        </member>
        <member name="F:PCRE.PcreMatchOptions.PartialHard">
            <summary>
            <c>PCRE2_PARTIAL_HARD</c> - Enable partial matching mode. Stop looking for a complete match if a partial match is found first.
            </summary>
            <remarks>
            <para>
            A partial match occurs if the end of the subject string is reached successfully, but there are not enough subject characters to complete the match.
            In addition, either at least one character must have been inspected or the pattern must contain a lookbehind, or the pattern must be one that could match an empty string.
            </para>
            <para>
            If this situation arises when <see cref="F:PCRE.PcreMatchOptions.PartialSoft"/> (but not <see cref="F:PCRE.PcreMatchOptions.PartialHard"/>) is set, matching continues by testing any remaining alternatives.
            Only if no complete match can be found is <see cref="F:PCRE.PcreErrorCode.Partial"/> returned instead of <see cref="F:PCRE.PcreErrorCode.NoMatch"/>.
            In other words, <see cref="F:PCRE.PcreMatchOptions.PartialSoft"/> specifies that the caller is prepared to handle a partial match, but only if no complete match can be found.
            </para>
            <para>
            If <see cref="F:PCRE.PcreMatchOptions.PartialHard"/> is set, it overrides <see cref="F:PCRE.PcreMatchOptions.PartialSoft"/>. In this case, if a partial match is found, <c>pcre2_match()</c> immediately returns <see cref="F:PCRE.PcreErrorCode.Partial"/>,
            without considering any other alternatives. In other words, when <see cref="F:PCRE.PcreMatchOptions.PartialHard"/> is set, a partial match is considered to be more important that an alternative complete match.
            </para>
            <para>
            There is a more detailed discussion of partial and multi-segment matching, with examples, in the pcre2partial documentation.
            </para>
            </remarks>
        </member>
        <member name="F:PCRE.PcreMatchOptions.NoUtfCheck">
            <summary>
            <c>PCRE2_NO_UTF_CHECK</c> - Disable validation of UTF sequences in the subject string.
            </summary>
            <remarks>
            <para>
            When <see cref="F:PCRE.PcreOptions.Utf"/> is set at compile time, the validity of the subject as a UTF string is checked unless <see cref="F:PCRE.PcreMatchOptions.NoUtfCheck"/> is passed to <c>pcre2_match()</c>
            or <see cref="F:PCRE.PcreOptions.MatchInvalidUtf"/> was passed to <c>pcre2_compile()</c>. The latter special case is discussed in detail in the pcre2unicode documentation.
            </para>
            <para>
            In the default case, if a non-zero starting offset is given, the check is applied only to that part of the subject that could be inspected during matching,
            and there is a check that the starting offset points to the first code unit of a character or to the end of the subject.
            If there are no lookbehind assertions in the pattern, the check starts at the starting offset.
            Otherwise, it starts at the length of the longest lookbehind before the starting offset, or at the start of the subject if there are not that many characters before the starting offset.
            Note that the sequences <c>\b</c> and <c>\B</c> are one-character lookbehinds.
            </para>
            <para>
            The check is carried out before any other processing takes place, and a negative error code is returned if the check fails.
            There are several UTF error codes for each code unit width, corresponding to different problems with the code unit sequence.
            There are discussions about the validity of UTF-8 strings, UTF-16 strings, and UTF-32 strings in the pcre2unicode documentation.
            If you know that your subject is valid, and you want to skip this check for performance reasons, you can set the <see cref="F:PCRE.PcreMatchOptions.NoUtfCheck"/> option when calling <c>pcre2_match()</c>.
            You might want to do this for the second and subsequent calls to <c>pcre2_match()</c> if you are making repeated calls to find multiple matches in the same subject string.
            </para>
            <para>
            Warning: Unless <see cref="F:PCRE.PcreOptions.MatchInvalidUtf"/> was set at compile time, when <see cref="F:PCRE.PcreMatchOptions.NoUtfCheck"/> is set at match time the effect of passing an invalid string as a subject,
            or an invalid value of startoffset, is undefined. Your program may crash or loop indefinitely or give wrong results.
            </para>
            </remarks>
        </member>
        <member name="F:PCRE.PcreMatchOptions.NoJit">
            <summary>
            <c>PCRE2_NO_JIT</c> - Disable the JIT for this match and use the interpreter instead.
            </summary>
            <remarks>
            By default, if a pattern has been successfully processed by <c>pcre2_jit_compile()</c>, JIT is automatically used when <c>pcre2_match()</c> is called with options that JIT supports.
            Setting <see cref="F:PCRE.PcreMatchOptions.NoJit"/> disables the use of JIT; it forces matching to be done by the interpreter.
            </remarks>
        </member>
        <member name="F:PCRE.PcreMatchOptions.DisableRecurseLoopCheck">
            <summary>
            <c>PCRE2_DISABLE_RECURSELOOP_CHECK</c> - Disable the check for repeated recursion in the interpreter.
            </summary>
            <remarks>
            <para>
            The use of recursion in patterns can lead to infinite loops. In the interpretive matcher these would be eventually caught by the match or heap limits,
            but this could take a long time and/or use a lot of memory if the limits are large. There is therefore a check at the start of each recursion.
            If the same group is still active from a previous call, and the current subject pointer is the same as it was at the start of that group, and the furthest inspected character
            of the subject has not changed, an error is generated.
            </para>
            <para>
            There are rare cases of matches that would complete, but nevertheless trigger this error. This option disables the check.
            It is provided mainly for testing when comparing JIT and interpretive behaviour.
            </para>
            </remarks>
        </member>
        <member name="T:PCRE.PcreMatchSettings">
            <summary>
            Advanced match settings.
            </summary>
        </member>
        <member name="P:PCRE.PcreMatchSettings.MatchLimit">
            <summary>
            Limit for the amount of backtracking that can take place.
            </summary>
            <remarks>
            <para>
            The <see cref="P:PCRE.PcreMatchSettings.MatchLimit"/> parameter provides a means of preventing PCRE2 from using up too many computing resources when processing patterns that are not going to match,
            but which have a very large number of possibilities in their search trees. The classic example is a pattern that uses nested unlimited repeats.
            </para>
            <para>
            There is an internal counter in <c>pcre2_match()</c> that is incremented each time round its main matching loop.
            If this value reaches the match limit, <c>pcre2_match()</c> returns the negative value <see cref="F:PCRE.PcreErrorCode.MatchLimit"/>.
            This has the effect of limiting the amount of backtracking that can take place.
            For patterns that are not anchored, the count restarts from zero for each position in the subject string.
            This limit also applies to <c>pcre2_dfa_match()</c>, though the counting is done in a different way.
            </para>
            <para>
            When <c>pcre2_match()</c> is called with a pattern that was successfully processed by <c>pcre2_jit_compile()</c>, the way in which matching is executed is entirely different.
            However, there is still the possibility of runaway matching that goes on for a very long time, and so the <see cref="P:PCRE.PcreMatchSettings.MatchLimit"/> value is also used in this case (but in a different way)
            to limit how long the matching can continue.
            </para>
            <para>
            The default value for the limit can be set when PCRE2 is built; the default default is 10 million, which handles all but the most extreme cases.
            A value for the match limit may also be supplied by an item at the start of a pattern of the form <c>(*LIMIT_MATCH=ddd)</c>
            where <c>ddd</c> is a decimal number. However, such a setting is ignored unless <c>ddd</c> is less than the limit set by the caller of <c>pcre2_match()</c> or <c>pcre2_dfa_match()</c> or,
            if no such limit is set, less than the default.
            </para>
            </remarks>
        </member>
        <member name="P:PCRE.PcreMatchSettings.DepthLimit">
            <summary>
            Depth limit of nested backtracking.
            </summary>
            <remarks>
            <para>
            This parameter limits the depth of nested backtracking in <c>pcre2_match()</c>. Each time a nested backtracking point is passed, a new memory "frame" is used to remember the
            state of matching at that point. Thus, this parameter indirectly limits the amount of memory that is used in a match.
            However, because the size of each memory "frame" depends on the number of capturing parentheses, the actual memory limit varies from pattern to pattern.
            This limit was more useful in versions before 10.30, where function recursion was used for backtracking.
            </para>
            <para>
            The depth limit is not relevant, and is ignored, when matching is done using JIT compiled code. However, it is supported by <c>pcre2_dfa_match()</c>,
            which uses it to limit the depth of nested internal recursive function calls that implement atomic groups, lookaround assertions, and pattern recursions.
            This limits, indirectly, the amount of system stack that is used. It was more useful in versions before 10.32, when stack memory was used for local workspace vectors for recursive function calls.
            From version 10.32, only local variables are allocated on the stack and as each call uses only a few hundred bytes, even a small stack can support quite a lot of recursion.
            </para>
            <para>
            If the depth of internal recursive function calls is great enough, local workspace vectors are allocated on the heap from version 10.32 onwards, so the depth limit also indirectly
            limits the amount of heap memory that is used. A recursive pattern such as <c>/(.(?2))((?1)|)/</c>, when matched to a very long string using <c>pcre2_dfa_match()</c>,
            can use a great deal of memory. However, it is probably better to limit heap usage directly by calling <c>pcre2_set_heap_limit()</c>.
            </para>
            <para>
            The default value for the depth limit can be set when PCRE2 is built; if it is not, the default is set to the same value as the default for the match limit.
            If the limit is exceeded, <c>pcre2_match()</c> or <c>pcre2_dfa_match()</c> returns <see cref="F:PCRE.PcreErrorCode.DepthLimit"/>.
            A value for the depth limit may also be supplied by an item at the start of a pattern of the form <c>(*LIMIT_DEPTH=ddd)</c>
            where <c>ddd</c> is a decimal number. However, such a setting is ignored unless <c>ddd</c> is less than the limit set by the caller of <c>pcre2_match()</c> or <c>pcre2_dfa_match()</c> or,
            if no such limit is set, less than the default.
            </para>
            </remarks>
        </member>
        <member name="P:PCRE.PcreMatchSettings.HeapLimit">
            <summary>
            Limit of heap memory that can be allocated at matching time, in KB.
            </summary>
            <remarks>
            <para>
            The <see cref="P:PCRE.PcreMatchSettings.HeapLimit"/> parameter specifies, in units of kibibytes (1024 bytes), the maximum amount of heap memory that <c>pcre2_match()</c> may use to hold backtracking information
            when running an interpretive match. This limit also applies to <c>pcre2_dfa_match()</c>, which may use the heap when processing patterns with a lot of nested pattern recursion
            or lookarounds or atomic groups. This limit does not apply to matching with the JIT optimization, which has its own memory control arrangements (see the pcre2jit documentation for more details).
            If the limit is reached, the negative error code <see cref="F:PCRE.PcreErrorCode.HeapLimit"/> is returned. The default limit can be set when PCRE2 is built;
            if it is not, the default is set very large and is essentially "unlimited".
            </para>
            <para>
            A value for the heap limit may also be supplied by an item at the start of a pattern of the form <c>(*LIMIT_HEAP=ddd)</c>
            where <c>ddd</c> is a decimal number. However, such a setting is ignored unless <c>ddd</c> is less than the limit set by the caller of <c>pcre2_match()</c> or,
            if no such limit is set, less than the default.
            </para>
            <para>
            The <c>pcre2_match()</c> function starts out using a 20KiB vector on the system stack for recording backtracking points.
            The more nested backtracking points there are (that is, the deeper the search tree), the more memory is needed. Heap memory is used only if the initial vector is too small.
            If the heap limit is set to a value less than 21 (in particular, zero) no heap memory will be used.
            In this case, only patterns that do not have a lot of nested backtracking can be successfully processed.
            </para>
            <para>
            Similarly, for <c>pcre2_dfa_match()</c>, a vector on the system stack is used when processing pattern recursions, lookarounds, or atomic groups,
            and only if this is not big enough is heap memory used. In this case, too, setting a value of zero disables the use of the heap.
            </para>
            </remarks>
        </member>
        <member name="P:PCRE.PcreMatchSettings.OffsetLimit">
            <summary>
            Limits how far a match can start after the initial start offset in the subject string.
            </summary>
            <remarks>
            <para>
            The <see cref="P:PCRE.PcreMatchSettings.OffsetLimit"/> parameter limits how far an unanchored search can advance in the subject string.
            The default value is <c>PCRE2_UNSET</c>. The <c>pcre2_match()</c> and <c>pcre2_dfa_match()</c> functions return <see cref="F:PCRE.PcreErrorCode.NoMatch"/> if a match with a starting point before
            or at the given offset is not found. The <c>pcre2_substitute()</c> function makes no more substitutions.
            </para>
            <para>
            For example, if the pattern <c>/abc/</c> is matched against "123abc" with an offset limit less than 3, the result is <see cref="F:PCRE.PcreErrorCode.NoMatch"/>.
            A match can never be found if the startoffset argument of <c>pcre2_match(),</c> <c>pcre2_dfa_match()</c>, or <c>pcre2_substitute()</c> is greater than the offset limit set in the match context.
            </para>
            <para>
            When using this facility, you must set the <see cref="F:PCRE.PcreOptions.UseOffsetLimit"/> option when calling <c>pcre2_compile()</c> so that when JIT is in use, different code can be compiled.
            If a match is started with a non-default match limit when <see cref="F:PCRE.PcreOptions.UseOffsetLimit"/> is not set, an error is generated.
            </para>
            <para>
            The offset limit facility can be used to track progress when searching large subject strings or to limit the extent of global substitutions.
            See also the <see cref="F:PCRE.PcreOptions.FirstLine"/> option, which requires a match to start before or at the first newline that follows the start of matching in the subject.
            If this is set with an offset limit, a match must occur in the first line and also within the offset limit. In other words, whichever limit comes first is used.
            </para>
            </remarks>
        </member>
        <member name="P:PCRE.PcreMatchSettings.JitStack">
            <summary>
            Assign a non-default stack for use by the JIT when matching a pattern.
            </summary>
        </member>
        <member name="T:PCRE.PcreNewLine">
            <summary>
            Specifies which character sequence is treated as a newline.
            </summary>
        </member>
        <member name="F:PCRE.PcreNewLine.Default">
            <summary>
            No information.
            </summary>
        </member>
        <member name="F:PCRE.PcreNewLine.Cr">
            <summary>
            <c>PCRE2_NEWLINE_CR</c> - Carriage return (CR).
            </summary>
        </member>
        <member name="F:PCRE.PcreNewLine.Lf">
            <summary>
            <c>PCRE2_NEWLINE_LF</c> - Linefeed (LF).
            </summary>
        </member>
        <member name="F:PCRE.PcreNewLine.CrLf">
            <summary>
            <c>PCRE2_NEWLINE_CRLF</c> - Carriage return, linefeed (CRLF).
            </summary>
        </member>
        <member name="F:PCRE.PcreNewLine.Any">
            <summary>
            <c>PCRE2_NEWLINE_ANY</c> - Any Unicode line ending.
            </summary>
        </member>
        <member name="F:PCRE.PcreNewLine.AnyCrLf">
            <summary>
            <c>PCRE2_NEWLINE_ANYCRLF</c> - Any of CR, LF, or CRLF.
            </summary>
        </member>
        <member name="F:PCRE.PcreNewLine.Nul">
            <summary>
            <c>PCRE2_NEWLINE_NUL</c> - The NUL character (binary zero).
            </summary>
        </member>
        <member name="T:PCRE.PcreOptions">
            <summary>
            Pattern compile options.
            </summary>
        </member>
        <member name="F:PCRE.PcreOptions.None">
            <summary>
            No additional options.
            </summary>
        </member>
        <member name="F:PCRE.PcreOptions.IgnoreCase">
            <inheritdoc cref="F:PCRE.PcreOptions.Caseless"/>
        </member>
        <member name="F:PCRE.PcreOptions.Singleline">
            <inheritdoc cref="F:PCRE.PcreOptions.DotAll"/>
        </member>
        <member name="F:PCRE.PcreOptions.ExplicitCapture">
            <inheritdoc cref="F:PCRE.PcreOptions.NoAutoCapture"/>
        </member>
        <member name="F:PCRE.PcreOptions.IgnorePatternWhitespace">
            <inheritdoc cref="F:PCRE.PcreOptions.Extended"/>
        </member>
        <member name="F:PCRE.PcreOptions.Unicode">
            <inheritdoc cref="F:PCRE.PcreOptions.Ucp"/>
        </member>
        <member name="F:PCRE.PcreOptions.JavaScript">
            <summary>
            Enable JavaScript-compatible mode.
            </summary>
            <remarks>
            This enables <see cref="F:PCRE.PcreOptions.AltBsUX"/> and <see cref="F:PCRE.PcreOptions.MatchUnsetBackref"/>.
            </remarks>
        </member>
        <member name="F:PCRE.PcreOptions.Compiled">
            <summary>
            JIT-compile the pattern for better performance.
            </summary>
        </member>
        <member name="F:PCRE.PcreOptions.CompiledPartial">
            <summary>
            Enable support for partial matching in a JIT-compiled pattern.
            </summary>
        </member>
        <member name="F:PCRE.PcreOptions.Caseless">
            <summary>
            <c>PCRE2_CASELESS</c> - Case-insensitive matching.
            </summary>
            <remarks>
            <para>
            If this bit is set, letters in the pattern match both upper and lower case letters in the subject.
            </para>
            <para>
            It is equivalent to Perl's <c>/i</c> option, and it can be changed within a pattern by a <c>(?i)</c> option setting.
            </para>
            <para>
            If either <see cref="F:PCRE.PcreOptions.Utf"/> or <see cref="F:PCRE.PcreOptions.Ucp"/> is set, Unicode properties are used for all characters with more than one other case,and for all characters whose code points are greater than U+007F.
            Note that there are two ASCII characters, K and S, that, in addition to their lower case ASCII equivalents, are case-equivalent with U+212A (Kelvin sign) and U+017F (long S) respectively.
            For lower valued characters with only one other case, a lookup table is used for speed. When neither <see cref="F:PCRE.PcreOptions.Utf"/> nor <see cref="F:PCRE.PcreOptions.Ucp"/> is set,
            a lookup table is used for all code points less than 256, and higher code points (available only in 16-bit or 32-bit mode) are treated as not having another case.
            </para>
            </remarks>
        </member>
        <member name="F:PCRE.PcreOptions.MultiLine">
            <summary>
            <c>PCRE2_MULTILINE</c> - Multiline mode. Make <c>^</c> and <c>$</c> match at the beginning and end, respectively, of any line.
            </summary>
            <remarks>
            <para>
            By default, for the purposes of matching "start of line" and "end of line", PCRE2 treats the subject string as consisting of a single line of characters, even if it actually contains newlines.
            The "start of line" metacharacter (<c>^</c>) matches only at the start of the string, and the "end of line" metacharacter (<c>$</c>) matches only at the end of the string,
            or before a terminating newline (except when <see cref="F:PCRE.PcreOptions.DollarEndOnly"/> is set).
            Note, however, that unless <see cref="F:PCRE.PcreOptions.DotAll"/> is set, the "any character" metacharacter (<c>.</c>) does not match at a newline.
            This behaviour (for <c>^</c>, <c>$</c>, and dot) is the same as Perl.
            </para>
            <para>
            When <see cref="F:PCRE.PcreOptions.MultiLine"/> it is set, the "start of line" and "end of line" constructs match immediately following or immediately before internal newlines in the subject string,
            respectively, as well as at the very start and end.
            </para>
            <para>
            This is equivalent to Perl's <c>/m</c> option, and it can be changed within a pattern by a <c>(?m)</c> option setting.
            </para>
            <para>
            Note that the "start of line" metacharacter does not match after a newline at the end of the subject, for compatibility with Perl.
            However, you can change this by setting the <see cref="F:PCRE.PcreOptions.AltCircumflex"/> option.
            If there are no newlines in a subject string, or no occurrences of <c>^</c> or <c>$</c> in a pattern, setting <see cref="F:PCRE.PcreOptions.MultiLine"/> has no effect.
            </para>
            </remarks>
        </member>
        <member name="F:PCRE.PcreOptions.DotAll">
            <summary>
            <c>PCRE2_DOTALL</c> - Single-line mode. Make the dot (<c>.</c>) match any character (including newlines).
            </summary>
            <remarks>
            <para>
            If this bit is set, a dot metacharacter in the pattern matches any character, including one that indicates a newline.
            However, it only ever matches one character, even if newlines are coded as CRLF. Without this option, a dot does not match when the current position in the subject is at a newline.
            </para>
            <para>
            This option is equivalent to Perl's <c>/s</c> option, and it can be changed within a pattern by a <c>(?s)</c> option setting.
            </para>
            <para>
            A negative class such as <c>[^a]</c> always matches newline characters, and the <c>\N</c> escape sequence always matches a non-newline character, independent of the setting of <see cref="F:PCRE.PcreOptions.DotAll"/>.
            </para>
            </remarks>
        </member>
        <member name="F:PCRE.PcreOptions.NoAutoCapture">
            <summary>
            <c>PCRE2_NO_AUTO_CAPTURE</c> - Disable capturing by unnamed groups. This makes capturing explicit.
            </summary>
            <remarks>
            <para>
            If this option is set, it disables the use of numbered capturing parentheses in the pattern.
            Any opening parenthesis that is not followed by <c>?</c> behaves as if it were followed by <c>?:</c> but named parentheses can still be used for capturing (and they acquire numbers in the usual way).
            </para>
            <para>
            This is the same as Perl's <c>/n</c> option.
            </para>
            <para>
            Note that, when this option is set, references to capture groups (backreferences or recursion/subroutine calls) may only refer to named groups, though the reference can be by name or by number.
            </para>
            </remarks>
        </member>
        <member name="F:PCRE.PcreOptions.Extended">
            <summary>
            <c>PCRE2_EXTENDED</c> - Extended mode. Ignore unescaped whitespace in the pattern. Enable comments marked with <c>#</c>.
            </summary>
            <remarks>
            <para>
            If this bit is set, most white space characters in the pattern are totally ignored except when escaped or inside a character class.
            However, white space is not allowed within sequences such as <c>(?&gt;</c> that introduce various parenthesized groups, nor within numerical quantifiers such as <c>{1,3}</c>.
            Ignorable white space is permitted between an item and a following quantifier and between a quantifier and a following <c>+</c> that indicates possessiveness.
            </para>
            <para>
            <see cref="F:PCRE.PcreOptions.Extended"/> is equivalent to Perl's <c>/x</c> option, and it can be changed within a pattern by a <c>(?x)</c> option setting.
            </para>
            <para>
            When PCRE2 is compiled without Unicode support, <see cref="F:PCRE.PcreOptions.Extended"/> recognizes as white space only those characters with code points less than 256 that are flagged as white space
            in its low-character table. The table is normally created by <c>pcre2_maketables()</c>, which uses the <c>isspace()</c> function to identify space characters.
            In most ASCII environments, the relevant characters are those with code points 0x0009 (tab), 0x000A (linefeed), 0x000B (vertical tab), 0x000C (formfeed), 0x000D (carriage return), and 0x0020 (space).
            </para>
            <para>
            When PCRE2 is compiled with Unicode support, in addition to these characters, five more Unicode "Pattern White Space" characters are recognized by <see cref="F:PCRE.PcreOptions.Extended"/>.
            These are U+0085 (next line), U+200E (left-to-right mark), U+200F (right-to-left mark), U+2028 (line separator), and U+2029 (paragraph separator).
            This set of characters is the same as recognized by Perl's <c>/x</c> option.
            Note that the horizontal and vertical space characters that are matched by the <c>\h</c> and <c>\v</c> escapes in patterns are a much bigger set.
            </para>
            <para>
            As well as ignoring most white space, <see cref="F:PCRE.PcreOptions.Extended"/> also causes characters between an unescaped <c>#</c> outside a character class and the next newline,
            inclusive, to be ignored, which makes it possible to include comments inside complicated patterns.
            Note that the end of this type of comment is a literal newline sequence in the pattern; escape sequences that happen to represent a newline do not count.
            Which characters are interpreted as newlines can be specified by a setting in the compile context that is passed to <c>pcre2_compile()</c> or by a special sequence
            at the start of the pattern, as described in the section entitled "Newline conventions" in the pcre2pattern documentation. A default is defined when PCRE2 is built.
            </para>
            </remarks>
        </member>
        <member name="F:PCRE.PcreOptions.ExtendedMore">
            <summary>
            <c>PCRE2_EXTENDED_MORE</c> - Extended mode that additionally ignores unescaped whitespace in character classes.
            </summary>
            <remarks>
            <para>
            This option has the effect of <see cref="F:PCRE.PcreOptions.Extended"/>, but, in addition, unescaped space and horizontal tab characters are ignored inside a character class.
            Note: only these two characters are ignored, not the full set of pattern white space characters that are ignored outside a character class.
            </para>
            <para>
            <see cref="F:PCRE.PcreOptions.ExtendedMore"/> is equivalent to Perl's <c>/xx</c> option, and it can be changed within a pattern by a <c>(?xx)</c> option setting.
            </para>
            </remarks>
        </member>
        <member name="F:PCRE.PcreOptions.AltBsUX">
            <summary>
            <c>PCRE2_ALT_BSUX</c> - Alternative handling of some escape sequences (ECMAScript-compliant behavior).
            </summary>
            <remarks>
            <para>
            This option request alternative handling of three escape sequences, which makes PCRE2's behaviour more like ECMAscript (aka JavaScript).
            When it is set:
            </para>
            <list type="bullet">
            <item>
            <c>\U</c> matches an upper case "U" character; by default <c>\U</c> causes a compile time error (Perl uses <c>\U</c> to upper case subsequent characters).
            </item>
            <item>
            <c>\u</c> matches a lower case "u" character unless it is followed by four hexadecimal digits, in which case the hexadecimal number defines the code point to match.
            By default, <c>\u</c> causes a compile time error (Perl uses it to upper case the following character).
            </item>
            <item>
            <c>\x</c> matches a lower case "x" character unless it is followed by two hexadecimal digits, in which case the hexadecimal number defines the code point to match.
            By default, as in Perl, a hexadecimal number is always expected after <c>\x</c>, but it may have zero, one, or two digits (so, for example, <c>\xz</c> matches a binary zero character followed by z).
            </item>
            </list>
            <para>
            ECMAscript 6 added additional functionality to <c>\u</c>. This can be accessed using the <see cref="F:PCRE.PcreExtraCompileOptions.AltBsUX"/> extra option (see <see cref="T:PCRE.PcreExtraCompileOptions"/>).
            Note that this alternative escape handling applies only to patterns. Neither of these options affects the processing of replacement strings passed to <c>pcre2_substitute()</c>.
            </para>
            </remarks>
        </member>
        <member name="F:PCRE.PcreOptions.MatchUnsetBackref">
            <summary>
            <c>PCRE2_MATCH_UNSET_BACKREF</c> - Make backreferences to unset groups match an empty string (ECMAScript-compliant behavior).
            </summary>
            <remarks>
            If this option is set, a backreference to an unset capture group matches an empty string (by default this causes the current matching alternative to fail).
            A pattern such as <c>(\1)(a)</c> succeeds when this option is set (assuming it can find an "a" in the subject), whereas it fails by default, for Perl compatibility.
            Setting this option makes PCRE2 behave more like ECMAscript (aka JavaScript).
            </remarks>
        </member>
        <member name="F:PCRE.PcreOptions.Literal">
            <summary>
            <c>PCRE2_LITERAL</c> - Treat the pattern as a literal string.
            </summary>
            <remarks>
            <para>
            If this option is set, all meta-characters in the pattern are disabled, and it is treated as a literal string.
            Matching literal strings with a regular expression engine is not the most efficient way of doing it.
            If you are doing a lot of literal matching and are worried about efficiency, you should consider using other approaches.
            </para>
            <para>
            The only other main options that are allowed with <see cref="F:PCRE.PcreOptions.Literal"/> are: <see cref="F:PCRE.PcreOptions.Anchored"/>, <see cref="F:PCRE.PcreOptions.EndAnchored"/>, <see cref="F:PCRE.PcreOptions.AutoCallout"/>, <see cref="F:PCRE.PcreOptions.Caseless"/>,
            <see cref="F:PCRE.PcreOptions.FirstLine"/>, <see cref="F:PCRE.PcreOptions.MatchInvalidUtf"/>, <see cref="F:PCRE.PcreOptions.NoStartOptimize"/>, <see cref="F:PCRE.PcreOptions.NoUtfCheck"/>, <see cref="F:PCRE.PcreOptions.Utf"/>, and <see cref="F:PCRE.PcreOptions.UseOffsetLimit"/>.
            The extra options <see cref="F:PCRE.PcreExtraCompileOptions.MatchLine"/> and <see cref="F:PCRE.PcreExtraCompileOptions.MatchWord"/> are also supported. Any other options cause an error.
            </para>
            </remarks>
        </member>
        <member name="F:PCRE.PcreOptions.Ucp">
            <summary>
            <c>PCRE2_UCP</c> - Use Unicode character properties.
            </summary>
            <remarks>
            <para>
            This option has two effects. Firstly, it changes the way PCRE2 processes <c>\B</c>, <c>\b</c>, <c>\D</c>, <c>\d</c>, <c>\S</c>, <c>\s</c>, <c>\W</c>, <c>\w</c>,
            and some of the POSIX character classes. By default, only ASCII characters are recognized, but if <see cref="F:PCRE.PcreOptions.Ucp"/> is set, Unicode properties are used instead to classify characters.
            More details are given in the section on generic character types in the pcre2pattern page. If you set <see cref="F:PCRE.PcreOptions.Ucp"/>, matching one of the items it affects takes much longer.
            </para>
            <para>
            The second effect of <see cref="F:PCRE.PcreOptions.Ucp"/> is to force the use of Unicode properties for upper/lower casing operations on characters with code points greater than 127,
            even when <see cref="F:PCRE.PcreOptions.Utf"/> is not set.
            This makes it possible, for example, to process strings in the 16-bit UCS-2 code. This option is available only if PCRE2 has been compiled with Unicode support (which is the default).
            </para>
            </remarks>
        </member>
        <member name="F:PCRE.PcreOptions.MatchInvalidUtf">
            <summary>
            <c>PCRE2_MATCH_INVALID_UTF</c> - Support matching invalid UTF sequences.
            </summary>
            <remarks>
            This option forces <see cref="F:PCRE.PcreOptions.Utf"/> and also enables support for matching by <c>pcre2_match()</c> in subject strings that contain invalid UTF sequences.
            This facility is not supported for DFA matching. For details, see the pcre2unicode documentation.
            </remarks>
        </member>
        <member name="F:PCRE.PcreOptions.Anchored">
            <summary>
            <c>PCRE2_ANCHORED</c> - Make the start of the pattern anchored, so it can only match at the starting position.
            </summary>
            <remarks>
            If this bit is set, the pattern is forced to be "anchored", that is, it is constrained to match only at the first matching point in the string that is being searched (the "subject string").
            This effect can also be achieved by appropriate constructs in the pattern itself, which is the only way to do it in Perl.
            </remarks>
            <seealso cref="F:PCRE.PcreMatchOptions.Anchored"/>
        </member>
        <member name="F:PCRE.PcreOptions.EndAnchored">
            <summary>
            <c>PCRE2_ENDANCHORED</c> - Make the end of the pattern anchored, so it needs to match until the end of the subject string.
            </summary>
            <remarks>
            <para>
            If this bit is set, the end of any pattern match must be right at the end of the string being searched (the "subject string").
            </para>
            <para>
            If the pattern match succeeds by reaching <c>(*ACCEPT)</c>, but does not reach the end of the subject, the match fails at the current starting point.
            For unanchored patterns, a new match is then tried at the next starting point.
            However, if the match succeeds by reaching the end of the pattern, but not the end of the subject, backtracking occurs and an alternative match may be found.
            </para>
            <para>
            Consider these two patterns:
            <list type="bullet">
            <item><c>.(*ACCEPT)|..</c></item>
            <item><c>.|..</c></item>
            </list>
            If matched against "abc" with <see cref="F:PCRE.PcreOptions.EndAnchored"/> set, the first matches "c" whereas the second matches "bc".
            The effect of <see cref="F:PCRE.PcreOptions.EndAnchored"/> can also be achieved by appropriate constructs in the pattern itself, which is the only way to do it in Perl.
            </para>
            <para>
            For DFA matching with <c>pcre2_dfa_match()</c>, <see cref="F:PCRE.PcreOptions.EndAnchored"/> applies only to the first (that is, the longest) matched string.
            Other parallel matches, which are necessarily substrings of the first one, must obviously end before the end of the subject.
            </para>
            </remarks>
            <seealso cref="F:PCRE.PcreMatchOptions.EndAnchored"/>
        </member>
        <member name="F:PCRE.PcreOptions.Ungreedy">
            <summary>
            <c>PCRE2_UNGREEDY</c> - Makes the quantifiers ungreedy by default.
            </summary>
            <remarks>
            This option inverts the "greediness" of the quantifiers so that they are not greedy by default, but become greedy if followed by "<c>?</c>".
            It is not compatible with Perl. It can also be set by a <c>(?U)</c> option setting within the pattern.
            </remarks>
        </member>
        <member name="F:PCRE.PcreOptions.FirstLine">
            <summary>
            <c>PCRE2_FIRSTLINE</c> - Match only until the first newline after the starting position.
            </summary>
            <remarks>
            <para>
            If this option is set, the start of an unanchored pattern match must be before or at the first newline in the subject string following the start of matching,
            though the matched text may continue over the newline. If startoffset is non-zero, the limiting newline is not necessarily the first newline in the subject.
            </para>
            <para>
            For example, if the subject string is "abc\nxyz" (where <c>\n</c> represents a single-character newline) a pattern match for "yz" succeeds with <see cref="F:PCRE.PcreOptions.FirstLine"/>
            if startoffset is greater than 3.
            See also <see cref="F:PCRE.PcreOptions.UseOffsetLimit"/>, which provides a more general limiting facility.
            </para>
            <para>
            If <see cref="F:PCRE.PcreOptions.FirstLine"/> is set with an offset limit, a match must occur in the first line and also within the offset limit. In other words, whichever limit comes first is used.
            </para>
            </remarks>
        </member>
        <member name="F:PCRE.PcreOptions.DupNames">
            <summary>
            <c>PCRE2_DUPNAMES</c> - Allow duplicate names for capturing groups.
            </summary>
            <remarks>
            If this bit is set, names used to identify capture groups need not be unique.
            This can be helpful for certain types of pattern when it is known that only one instance of the named group can ever be matched.
            See also the pcre2pattern documentation.
            </remarks>
        </member>
        <member name="F:PCRE.PcreOptions.AutoCallout">
            <summary>
            <c>PCRE2_AUTO_CALLOUT</c> - Automatically insert callouts before each pattern item except next to other callouts.
            </summary>
            <remarks>
            If this bit is set, <c>pcre2_compile()</c> automatically inserts callout items, all with number 255, before each pattern item,
            except immediately before or after an explicit callout in the pattern. For discussion of the callout facility, see the pcre2callout documentation.
            </remarks>
        </member>
        <member name="F:PCRE.PcreOptions.NoStartOptimize">
            <summary>
            <c>PCRE2_NO_START_OPTIMIZE</c> - Disables optimizations applied at the start of a match.
            </summary>
            <remarks>
            <para>
            This is an option whose main effect is at matching time. It does not change what <c>pcre2_compile()</c> generates, but it does affect the output of the JIT compiler.
            </para>
            <para>
            There are a number of optimizations that may occur at the start of a match, in order to speed up the process.
            For example, if it is known that an unanchored match must start with a specific code unit value, the matching code searches the subject for that value,
            and fails immediately if it cannot find it, without actually running the main matching function.
            </para>
            <para>
            This means that a special item such as <c>(*COMMIT)</c> at the start of a pattern is not considered until after a suitable starting point for the match has been found.
            Also, when callouts or <c>(*MARK)</c> items are in use, these "start-up" optimizations can cause them to be skipped if the pattern is never actually used.
            </para>
            <para>
            The start-up optimizations are in effect a pre-scan of the subject that takes place before the pattern is run.
            The <see cref="F:PCRE.PcreOptions.NoStartOptimize"/> option disables the start-up optimizations, possibly causing performance to suffer,
            but ensuring that in cases where the result is "no match", the callouts do occur, and that items such as <c>(*COMMIT)</c> and <c>(*MARK)</c> are considered
            at every possible starting position in the subject string.
            </para>
            <para>
            Setting <see cref="F:PCRE.PcreOptions.NoStartOptimize"/> may change the outcome of a matching operation. Consider the pattern <c>(*COMMIT)ABC</c>.
            When this is compiled, PCRE2 records the fact that a match must start with the character "A".
            Suppose the subject string is "DEFABC". The start-up optimization scans along the subject, finds "A" and runs the first match attempt from there.
            The <c>(*COMMIT)</c> item means that the pattern must match the current starting position, which in this case, it does.
            However, if the same match is run with <see cref="F:PCRE.PcreOptions.NoStartOptimize"/> set, the initial scan along the subject string does not happen.
            The first match attempt is run starting from "D" and when this fails, <c>(*COMMIT)</c> prevents any further matches being tried, so the overall result is "no match".
            </para>
            <para>
            As another start-up optimization makes use of a minimum length for a matching subject, which is recorded when possible. Consider the pattern <c>(*MARK:1)B(*MARK:2)(X|Y)</c>.
            The minimum length for a match is two characters. If the subject is "XXBB", the "starting character" optimization skips "XX", then tries to match "BB", which is long enough.
            In the process, <c>(*MARK:2)</c> is encountered and remembered. When the match attempt fails, the next "B" is found, but there is only one character left, so there are no more attempts,
            and "no match" is returned with the "last mark seen" set to "2".
            If <see cref="F:PCRE.PcreOptions.NoStartOptimize"/> is set, however, matches are tried at every possible starting position, including at the end of the subject,
            where <c>(*MARK:1)</c> is encountered, but there is no "B", so the "last mark seen" that is returned is "1".
            In this case, the optimizations do not affect the overall match result, which is still "no match", but they do affect the auxiliary information that is returned.
            </para>
            </remarks>
        </member>
        <member name="F:PCRE.PcreOptions.NoAutoPossess">
            <summary>
            <c>PCRE2_NO_AUTO_POSSESS</c> - Disable the auto-possessification optimization.
            </summary>
            <remarks>
            <para>
            If this option is set, it disables "auto-possessification", which is an optimization that, for example, turns <c>a+b</c> into <c>a++b</c>
            in order to avoid backtracks into <c>a+</c> that can never be successful.
            </para>
            <para>
            However, if callouts are in use, auto-possessification means that some callouts are never taken.
            You can set this option if you want the matching functions to do a full unoptimized search and run all the callouts, but it is mainly provided for testing purposes.
            </para>
            </remarks>
        </member>
        <member name="F:PCRE.PcreOptions.DollarEndOnly">
            <summary>
            <c>PCRE2_DOLLAR_ENDONLY</c> - Make <c>$</c> match only at the end of the subject string.
            </summary>
            <remarks>
            <para>
            If this bit is set, a dollar metacharacter in the pattern matches only at the end of the subject string.
            Without this option, a dollar also matches immediately before a newline at the end of the string (but not before any other newlines).
            </para>
            <para>
            The <see cref="F:PCRE.PcreOptions.DollarEndOnly"/> option is ignored if <see cref="F:PCRE.PcreOptions.MultiLine"/> is set.
            There is no equivalent to this option in Perl, and no way to set it within a pattern.
            </para>
            </remarks>
        </member>
        <member name="F:PCRE.PcreOptions.AltCircumflex">
            <summary>
            <c>PCRE2_ALT_CIRCUMFLEX</c> - Make <c>^</c> match after a newline at the end of the subject string.
            </summary>
            <remarks>
            In multiline mode (when <see cref="F:PCRE.PcreOptions.MultiLine"/> is set), the circumflex metacharacter matches at the start of the subject (unless <see cref="F:PCRE.PcreMatchOptions.NotBol"/> is set),
            and also after any internal newline. However, it does not match after a newline at the end of the subject, for compatibility with Perl.
            If you want a multiline circumflex also to match after a terminating newline, you must set <see cref="F:PCRE.PcreOptions.AltCircumflex"/>.
            </remarks>
        </member>
        <member name="F:PCRE.PcreOptions.AltVerbNames">
            <summary>
            <c>PCRE2_ALT_VERBNAMES</c> - Allow escaped closing parentheses in a verb name.
            </summary>
            <remarks>
            <para>
            By default, for compatibility with Perl, the name in any verb sequence such as <c>(*MARK:NAME)</c> is any sequence of characters that does not include a closing parenthesis.
            The name is not processed in any way, and it is not possible to include a closing parenthesis in the name.
            </para>
            <para>
            However, if the <see cref="F:PCRE.PcreOptions.AltVerbNames"/> option is set, normal backslash processing is applied to verb names and only an unescaped closing parenthesis terminates the name.
            A closing parenthesis can be included in a name either as <c>\)</c> or between <c>\Q</c> and <c>\E</c>.
            </para>
            <para>
            If the <see cref="F:PCRE.PcreOptions.Extended"/> or <see cref="F:PCRE.PcreOptions.ExtendedMore"/> option is set with <see cref="F:PCRE.PcreOptions.AltVerbNames"/>, unescaped whitespace in verb names is skipped
            and <c>#</c>-comments are recognized, exactly as in the rest of the pattern.
            </para>
            </remarks>
        </member>
        <member name="F:PCRE.PcreOptions.AllowEmptyClass">
            <summary>
            <c>PCRE2_ALLOW_EMPTY_CLASS</c> - Allow empty character classes.
            </summary>
            <remarks>
            By default, for compatibility with Perl, a closing square bracket that immediately follows an opening one is treated as a data character for the class.
            When <see cref="F:PCRE.PcreOptions.AllowEmptyClass"/> is set, it terminates the class, which therefore contains no characters and so can never match.
            </remarks>
        </member>
        <member name="F:PCRE.PcreOptions.NoDotStarAnchor">
            <summary>
            <c>PCRE2_NO_DOTSTAR_ANCHOR</c> - Disable optimizing branches starting with <c>.*</c>.
            </summary>
            <remarks>
            <para>
            If this option is set, it disables an optimization that is applied when <c>.*</c> is the first significant item in a top-level branch of a pattern,
            and all the other branches also start with <c>.*</c> or with <c>\A</c> or <c>\G</c> or <c>^</c>.
            </para>
            <para>
            The optimization is automatically disabled for <c>.*</c> if it is inside an atomic group or a capture group that is the subject of a backreference,
            or if the pattern contains <c>(*PRUNE)</c> or <c>(*SKIP)</c>.
            </para>
            <para>
            When the optimization is not disabled, such a pattern is automatically anchored if <see cref="F:PCRE.PcreOptions.DotAll"/> is set for all the <c>.*</c> items and <see cref="F:PCRE.PcreOptions.MultiLine"/>
            is not set for any <c>^</c> items.
            Otherwise, the fact that any match must start either at the start of the subject or following a newline is remembered.
            </para>
            <para>
            Like other optimizations, this can cause callouts to be skipped.
            </para>
            </remarks>
        </member>
        <member name="F:PCRE.PcreOptions.NoUtfCheck">
            <summary>
            <c>PCRE2_NO_UTF_CHECK</c> - Disable validation of UTF sequences in the pattern string.
            </summary>
            <remarks>
            <para>
            When <see cref="F:PCRE.PcreOptions.Utf"/> is set, the validity of the pattern as a UTF string is automatically checked.
            There are discussions about the validity of UTF-8 strings, UTF-16 strings, and UTF-32 strings in the pcre2unicode document.
            If an invalid UTF sequence is found, <c>pcre2_compile()</c> returns a negative error code.
            </para>
            <para>
            If you know that your pattern is a valid UTF string, and you want to skip this check for performance reasons, you can set the <see cref="F:PCRE.PcreOptions.NoUtfCheck"/> option.
            When it is set, the effect of passing an invalid UTF string as a pattern is undefined. It may cause your program to crash or loop.
            </para>
            <para>
            Note that this option can also be passed to <c>pcre2_match()</c> and <c>pcre_dfa_match()</c>, to suppress UTF validity checking of the subject string.
            Note also that setting <see cref="F:PCRE.PcreOptions.NoUtfCheck"/> at compile time does not disable the error that is given if an escape sequence for an invalid Unicode code point
            is encountered in the pattern. In particular, the so-called "surrogate" code points (0xd800 to 0xdfff) are invalid.
            If you want to allow escape sequences such as <c>\x{d800}</c> you can set the <see cref="F:PCRE.PcreExtraCompileOptions.AllowSurrogateEscapes"/> extra option, as described in
            <see cref="T:PCRE.PcreExtraCompileOptions"/>. However, this is possible only in UTF-8 and UTF-32 modes, because these values are not representable in UTF-16.
            </para>
            </remarks>
        </member>
        <member name="F:PCRE.PcreOptions.NeverUcp">
            <summary>
            <c>PCRE2_NEVER_UCP</c> - Disallow using Unicode character properties.
            </summary>
            <remarks>
            <para>
            This option locks out the use of Unicode properties for handling <c>\B</c>, <c>\b</c>, <c>\D</c>, <c>\d</c>, <c>\S</c>, <c>\s</c>, <c>\W</c>, <c>\w</c>,
            and some of the POSIX character classes, as described for the <see cref="F:PCRE.PcreOptions.Ucp"/> option.
            </para>
            <para>
            In particular, it prevents the creator of the pattern from enabling this facility by starting the pattern with <c>(*UCP)</c>.
            This option may be useful in applications that process patterns from external sources. The option combination <see cref="F:PCRE.PcreOptions.Ucp"/> and <see cref="F:PCRE.PcreOptions.NeverUcp"/> causes an error.
            </para>
            </remarks>
        </member>
        <member name="F:PCRE.PcreOptions.NeverBackslashC">
            <summary>
            <c>PCRE2_NEVER_BACKSLASH_C</c> - Disallow using <c>\C</c> in the pattern.
            </summary>
            <remarks>
            <para>
            This option locks out the use of <c>\C</c> in the pattern that is being compiled.
            This escape can cause unpredictable behaviour in UTF-8 or UTF-16 modes, because it may leave the current matching point in the middle of a multi-code-unit character.
            </para>
            <para>
            This option may be useful in applications that process patterns from external sources. Note that there is also a build-time option that permanently locks out the use of <c>\C</c>.
            </para>
            </remarks>
        </member>
        <member name="F:PCRE.PcreOptions.UseOffsetLimit">
            <summary>
            <c>PCRE2_USE_OFFSET_LIMIT</c> - Allow setting a non-default offset limit.
            </summary>
            <remarks>
            This option must be set for <c>pcre2_compile()</c> if <c>pcre2_set_offset_limit()</c> is going to be used to set a non-default offset limit in a match context
            for matches that use this pattern. An error is generated if an offset limit is set without this option.
            For more details, see the description of <c>pcre2_set_offset_limit()</c> in the section that describes match contexts. See also the <see cref="F:PCRE.PcreOptions.FirstLine"/> option.
            </remarks>
        </member>
        <member name="F:PCRE.PcreOptions.Utf">
            <summary>
            <c>PCRE2_UTF</c> - Enable UTF mode.
            </summary>
            <remarks>
            This option causes PCRE2 to regard both the pattern and the subject strings that are subsequently processed as strings of UTF characters instead of single-code-unit strings.
            It is available when PCRE2 is built to include Unicode support (which is the default). If Unicode support is not available, the use of this option provokes an error.
            Details of how <see cref="F:PCRE.PcreOptions.Utf"/> changes the behaviour of PCRE2 are given in the pcre2unicode page.
            In particular, note that it changes the way <see cref="F:PCRE.PcreOptions.Caseless"/> handles characters with code points greater than 127.
            </remarks>
        </member>
        <member name="T:PCRE.PcrePatternInfo">
            <summary>
            Information about a regex pattern.
            </summary>
        </member>
        <member name="P:PCRE.PcrePatternInfo.PatternString">
            <summary>
            Returns the regex pattern string.
            </summary>
        </member>
        <member name="P:PCRE.PcrePatternInfo.Settings">
            <summary>
            Returns the advanced settings that were used.
            </summary>
        </member>
        <member name="P:PCRE.PcrePatternInfo.Options">
            <summary>
            Returns the options used for pattern compilation.
            </summary>
        </member>
        <member name="P:PCRE.PcrePatternInfo.JitOptions">
            <summary>
            Returns the JIT options used for pattern compilation.
            </summary>
        </member>
        <member name="P:PCRE.PcrePatternInfo.CaptureCount">
            <summary>
            Returns the capturing groups count.
            </summary>
        </member>
        <member name="P:PCRE.PcrePatternInfo.ArgOptions">
            <summary>
            <c>PCRE2_INFO_ARGOPTIONS</c> - Returns the options used for pattern compilation.
            </summary>
        </member>
        <member name="P:PCRE.PcrePatternInfo.AllOptions">
            <summary>
            <c>PCRE2_INFO_ALLOPTIONS</c> - Returns the options used for pattern compilation
            as modified by any top-level <c>(*XXX)</c> option settings such as <c>(*UTF)</c> at the start of the pattern itself.
            </summary>
        </member>
        <member name="P:PCRE.PcrePatternInfo.ExtraOptions">
            <summary>
            <c>PCRE2_INFO_EXTRAOPTIONS</c> - Returns the extra options used for pattern compilation.
            </summary>
        </member>
        <member name="P:PCRE.PcrePatternInfo.MaxBackReference">
            <summary>
            <c>PCRE2_INFO_BACKREFMAX</c> - Returns the number of the highest backreference in the pattern.
            </summary>
            <remarks>
            Named capture groups acquire numbers as well as names, and these count towards the highest backreference.
            Backreferences such as <c>\4</c> or <c>\g{12}</c> match the captured characters of the given group, but in addition,
            the check that a capture group is set in a conditional group such as <c>(?(3)a|b)</c> is also a backreference.
            Zero is returned if there are no backreferences.
            </remarks>
        </member>
        <member name="P:PCRE.PcrePatternInfo.IsCompiled">
            <summary>
            <c>PCRE2_INFO_JITSIZE</c> - Returns the size of the JIT compiled code, or zero if the pattern wasn't JIT-compiled.
            </summary>
        </member>
        <member name="P:PCRE.PcrePatternInfo.CanMatchEmptyString">
            <summary>
            <c>PCRE2_INFO_MATCHEMPTY</c> - Indicates of the pattern might match an empty string.
            </summary>
        </member>
        <member name="P:PCRE.PcrePatternInfo.MaxLookBehind">
            <summary>
            <c>PCRE2_INFO_MAXLOOKBEHIND</c> - Maximum length of a lookbehind.
            </summary>
            <remarks>
            A lookbehind assertion moves back a certain number of characters (not code units) when it starts to process each of its branches.
            This request returns the largest of these backward moves.
            The simple assertions <c>\b</c> and <c>\B</c> require a one-character lookbehind and cause <see cref="P:PCRE.PcrePatternInfo.MaxLookBehind"/> to return 1 in the absence of anything longer.
            <c>\A</c> also registers a one-character lookbehind, though it does not actually inspect the previous character.
            Note that this information is useful for multi-segment matching only if the pattern contains no nested lookbehinds.
            For example, the pattern <c>(?&lt;=a(?&lt;=ba)c)</c> returns a maximum lookbehind of 2, but when it is processed,
            the first lookbehind moves back by two characters, matches one character, then the nested lookbehind also moves back by two characters.
            This puts the matching point three characters earlier than it was at the start.
            <see cref="P:PCRE.PcrePatternInfo.MaxLookBehind"/> is really only useful as a debugging tool.
            </remarks>
        </member>
        <member name="P:PCRE.PcrePatternInfo.MinSubjectLength">
            <summary>
            <c>PCRE2_INFO_MINLENGTH</c> - The minimum length for matching subject strings if computed, or zero otherwise.
            </summary>
            <remarks>
            This value is not computed when <see cref="F:PCRE.PcreOptions.NoStartOptimize"/> is set.
            The value is a number of characters, which in UTF mode may be different from the number of code units.
            The value is a lower bound to the length of any matching string.
            There may not be any strings of that length that do actually match, but every string that does match is at least that long.
            </remarks>
        </member>
        <member name="P:PCRE.PcrePatternInfo.NamedGroupsCount">
            <summary>
            <c>PCRE2_INFO_NAMECOUNT</c> - The count of named capturing groups.
            </summary>
        </member>
        <member name="P:PCRE.PcrePatternInfo.DepthLimit">
            <summary>
            <c>PCRE2_INFO_DEPTHLIMIT</c> - Returns the backtracking depth limit if the pattern specified it
            by including an item of the form <c>(*LIMIT_DEPTH=nnnn)</c> at the start.
            </summary>
            <remarks>
            Note that this limit will only be used during matching if it is less than the limit set or defaulted by the caller of the match function.
            </remarks>
        </member>
        <member name="P:PCRE.PcrePatternInfo.BackslashR">
            <summary>
            <c>PCRE2_INFO_BSR</c> - Indicates what character sequences the <c>\R</c> escape sequence matches.
            </summary>
        </member>
        <member name="P:PCRE.PcrePatternInfo.HasBackslashC">
            <summary>
            <c>PCRE2_INFO_HASBACKSLASHC</c> - Indicates if the pattern contains any instances of <c>\C</c>.
            </summary>
        </member>
        <member name="P:PCRE.PcrePatternInfo.HasCrOrLf">
            <summary>
            <c>PCRE2_INFO_HASCRORLF</c> - Indicates if the pattern contains any explicit matches for CR or LF characters.
            </summary>
            <remarks>
            An explicit match is either a literal CR or LF character, or <c>\r</c> or <c>\n</c> or one of the equivalent hexadecimal or octal escape sequences.
            </remarks>
        </member>
        <member name="P:PCRE.PcrePatternInfo.JChanged">
            <summary>
            <c>PCRE2_INFO_JCHANGED</c> - Indicates if the <c>(?J)</c> or <c>(?-J)</c> option setting is used in the pattern.
            </summary>
            <remarks>
            <c>(?J)</c> and <c>(?-J)</c> set and unset the local <see cref="F:PCRE.PcreOptions.DupNames"/> option, respectively.
            </remarks>
        </member>
        <member name="P:PCRE.PcrePatternInfo.FrameSize">
            <summary>
            <c>PCRE2_INFO_FRAMESIZE</c> - Returns the size (in bytes) of the data frames that are used to remember backtracking positions
            when the pattern is processed without the use of JIT.
            </summary>
            <remarks>
            The frame size depends on the number of capturing parentheses in the pattern. Each additional capture group adds two <see cref="T:System.IntPtr"/> variables.
            </remarks>
        </member>
        <member name="P:PCRE.PcrePatternInfo.JitSize">
            <summary>
            <c>PCRE2_INFO_JITSIZE</c> - Returns the size of the JIT compiled code.
            </summary>
        </member>
        <member name="P:PCRE.PcrePatternInfo.PatternSize">
            <summary>
            <c>PCRE2_INFO_SIZE</c> - Returns the size of the compiled pattern in bytes.
            </summary>
            <remarks>
            This value includes the size of the general data block that precedes the code units of the compiled pattern itself.
            Processing a pattern with the JIT compiler does not alter the value returned by this option.
            </remarks>
        </member>
        <member name="P:PCRE.PcrePatternInfo.MatchLimit">
            <summary>
            <c>PCRE2_INFO_MATCHLIMIT</c> - Returns the value of the match limit set by <c>(*LIMIT_MATCH=nnnn)</c> at the start of the pattern.
            </summary>
        </member>
        <member name="P:PCRE.PcrePatternInfo.HeapLimit">
            <summary>
            <c>PCRE2_INFO_HEAPLIMIT</c> - Returns the value of the heap limit set by <c>(*LIMIT_HEAP=nnnn)</c> at the start of the pattern.
            </summary>
        </member>
        <member name="P:PCRE.PcrePatternInfo.FirstCodeType">
            <summary>
            <c>PCRE2_INFO_FIRSTCODETYPE</c> - Returns information about the first code unit of any matched string, for a non-anchored pattern.
            </summary>
            <remarks>
            If there is a fixed first value, for example, the letter "c" from a pattern such as <c>(cat|cow|coyote)</c>, true is returned,
            and the value can be retrieved using <see cref="P:PCRE.PcrePatternInfo.FirstCodeUnit"/>. If there is no fixed first value, but it is known that a match
            can occur only at the start of the subject or following a newline in the subject, 2 is returned. Otherwise, and for anchored patterns, 0 is returned.
            </remarks>
        </member>
        <member name="P:PCRE.PcrePatternInfo.FirstCodeUnit">
            <summary>
            <c>PCRE2_INFO_FIRSTCODEUNIT</c> - Returns the value of the first code unit of any matched string for a pattern where <see cref="P:PCRE.PcrePatternInfo.FirstCodeType"/> is true.
            </summary>
        </member>
        <member name="P:PCRE.PcrePatternInfo.LastCodeType">
            <summary>
            <c>PCRE2_INFO_LASTCODETYPE</c> - Returns true if there is a rightmost literal code unit that must exist in any matched string, other than at its start.
            </summary>
            <remarks>
            When true, the code unit value itself can be retrieved using <see cref="P:PCRE.PcrePatternInfo.LastCodeUnit"/>. For anchored patterns, a last literal value is recorded only
            if it follows something of variable length. For example, for the pattern <c>/^a\d+z\d+/</c> the returned value is 1 (with "z" returned from <see cref="P:PCRE.PcrePatternInfo.LastCodeUnit"/>),
            but for <c>/^a\dz\d/</c> the returned value is 0.
            </remarks>
        </member>
        <member name="P:PCRE.PcrePatternInfo.LastCodeUnit">
            <summary>
            <c>PCRE2_INFO_LASTCODEUNIT</c> - Return the value of the rightmost literal code unit that must exist in any matched string, other than at its start,
            for a pattern where <see cref="P:PCRE.PcrePatternInfo.LastCodeType"/> returns true.
            </summary>
        </member>
        <member name="P:PCRE.PcrePatternInfo.Callouts">
            <summary>
            Returns the list of callouts in the pattern.
            </summary>
        </member>
        <member name="P:PCRE.PcrePatternInfo.GroupNames">
            <summary>
            Returns the list of group names in the pattern.
            </summary>
        </member>
        <member name="M:PCRE.PcrePatternInfo.GetGroupIndexesByName(System.String)">
            <summary>
            Returns the list of indexes in the pattern for a given capturing group name.
            </summary>
            <param name="name">The capturing group name.</param>
        </member>
        <member name="T:PCRE.PcreRefCalloutFunc">
            <summary>
            A callout function.
            </summary>
        </member>
        <member name="T:PCRE.PcreRefCallout">
            <inheritdoc cref="T:PCRE.PcreCallout"/>
        </member>
        <member name="P:PCRE.PcreRefCallout.Number">
            <inheritdoc cref="P:PCRE.PcreCallout.Number"/>
        </member>
        <member name="P:PCRE.PcreRefCallout.Match">
            <inheritdoc cref="P:PCRE.PcreCallout.Match"/>
        </member>
        <member name="P:PCRE.PcreRefCallout.StartOffset">
            <inheritdoc cref="P:PCRE.PcreCallout.StartOffset"/>
        </member>
        <member name="P:PCRE.PcreRefCallout.CurrentOffset">
            <inheritdoc cref="P:PCRE.PcreCallout.CurrentOffset"/>
        </member>
        <member name="P:PCRE.PcreRefCallout.MaxCapture">
            <inheritdoc cref="P:PCRE.PcreCallout.MaxCapture"/>
        </member>
        <member name="P:PCRE.PcreRefCallout.LastCapture">
            <inheritdoc cref="P:PCRE.PcreCallout.LastCapture"/>
        </member>
        <member name="P:PCRE.PcreRefCallout.PatternPosition">
            <inheritdoc cref="P:PCRE.PcreCallout.PatternPosition"/>
        </member>
        <member name="P:PCRE.PcreRefCallout.NextPatternItemLength">
            <inheritdoc cref="P:PCRE.PcreCallout.NextPatternItemLength"/>
        </member>
        <member name="P:PCRE.PcreRefCallout.StringOffset">
            <inheritdoc cref="P:PCRE.PcreCallout.StringOffset"/>
        </member>
        <member name="P:PCRE.PcreRefCallout.String">
            <inheritdoc cref="P:PCRE.PcreCallout.String"/>
        </member>
        <member name="P:PCRE.PcreRefCallout.Info">
            <inheritdoc cref="P:PCRE.PcreCallout.Info"/>
        </member>
        <member name="P:PCRE.PcreRefCallout.StartMatch">
            <inheritdoc cref="P:PCRE.PcreCallout.StartMatch"/>
        </member>
        <member name="P:PCRE.PcreRefCallout.Backtrack">
            <inheritdoc cref="P:PCRE.PcreCallout.Backtrack"/>
        </member>
        <member name="T:PCRE.PcreRefGroup">
            <summary>
            The result of a capturing group.
            </summary>
        </member>
        <member name="T:PCRE.PcreRefGroup.Func`1">
            <summary>
            A function which returns an output value out of a group.
            </summary>
            <typeparam name="T">The output value type.</typeparam>
        </member>
        <member name="P:PCRE.PcreRefGroup.Index">
            <inheritdoc cref="P:PCRE.PcreGroup.Index"/>
        </member>
        <member name="P:PCRE.PcreRefGroup.EndIndex">
            <inheritdoc cref="P:PCRE.PcreGroup.EndIndex"/>
        </member>
        <member name="P:PCRE.PcreRefGroup.Length">
            <inheritdoc cref="P:PCRE.PcreGroup.Length"/>
        </member>
        <member name="P:PCRE.PcreRefGroup.Value">
            <inheritdoc cref="P:PCRE.PcreGroup.Value"/>
        </member>
        <member name="P:PCRE.PcreRefGroup.Success">
            <inheritdoc cref="P:PCRE.PcreGroup.Success"/>
        </member>
        <member name="P:PCRE.PcreRefGroup.IsDefined">
            <inheritdoc cref="P:PCRE.PcreGroup.IsDefined"/>
        </member>
        <member name="M:PCRE.PcreRefGroup.op_Implicit(PCRE.PcreRefGroup)~System.String">
            <inheritdoc cref="M:PCRE.PcreGroup.op_Implicit(PCRE.PcreGroup)~System.String"/>
        </member>
        <member name="M:PCRE.PcreRefGroup.ToString">
            <inheritdoc cref="M:PCRE.PcreGroup.ToString"/>
        </member>
        <member name="T:PCRE.PcreRefMatch">
            <summary>
            The result of a match.
            </summary>
        </member>
        <member name="T:PCRE.PcreRefMatch.Func`1">
            <summary>
            A function which returns an output value out of a match.
            </summary>
            <typeparam name="T">The output value type.</typeparam>
        </member>
        <member name="P:PCRE.PcreRefMatch.CaptureCount">
            <inheritdoc cref="P:PCRE.PcreMatch.CaptureCount"/>
        </member>
        <member name="P:PCRE.PcreRefMatch.Item(System.Int32)">
            <summary>
            Returns the capturing group at a given index.
            </summary>
            <param name="index">The index of the capturing group.</param>
        </member>
        <member name="P:PCRE.PcreRefMatch.Item(System.String)">
            <summary>
            Returns the capturing group of a given name.
            </summary>
            <param name="name">The name of the capturing group.</param>
        </member>
        <member name="P:PCRE.PcreRefMatch.Index">
            <inheritdoc cref="P:PCRE.PcreMatch.Index"/>
        </member>
        <member name="P:PCRE.PcreRefMatch.EndIndex">
            <inheritdoc cref="P:PCRE.PcreMatch.EndIndex"/>
        </member>
        <member name="P:PCRE.PcreRefMatch.Length">
            <inheritdoc cref="P:PCRE.PcreMatch.Length"/>
        </member>
        <member name="P:PCRE.PcreRefMatch.Success">
            <inheritdoc cref="P:PCRE.PcreMatch.Success"/>
        </member>
        <member name="P:PCRE.PcreRefMatch.Value">
            <inheritdoc cref="P:PCRE.PcreMatch.Value"/>
        </member>
        <member name="P:PCRE.PcreRefMatch.Mark">
            <inheritdoc cref="P:PCRE.PcreMatch.Mark"/>
        </member>
        <member name="P:PCRE.PcreRefMatch.Groups">
            <inheritdoc cref="P:PCRE.PcreMatch.Groups"/>
        </member>
        <member name="P:PCRE.PcreRefMatch.IsPartialMatch">
            <inheritdoc cref="P:PCRE.PcreMatch.IsPartialMatch"/>
        </member>
        <member name="M:PCRE.PcreRefMatch.GetEnumerator">
            <inheritdoc cref="M:PCRE.PcreMatch.GetEnumerator"/>
        </member>
        <member name="M:PCRE.PcreRefMatch.TryGetGroup(System.Int32,PCRE.PcreRefGroup@)">
            <inheritdoc cref="M:PCRE.PcreMatch.TryGetGroup(System.Int32,PCRE.PcreGroup@)"/>
        </member>
        <member name="M:PCRE.PcreRefMatch.TryGetGroup(System.String,PCRE.PcreRefGroup@)">
            <inheritdoc cref="M:PCRE.PcreMatch.TryGetGroup(System.String,PCRE.PcreGroup@)"/>
        </member>
        <member name="M:PCRE.PcreRefMatch.GetDuplicateNamedGroups(System.String)">
            <inheritdoc cref="M:PCRE.PcreMatch.GetDuplicateNamedGroups(System.String)"/>
        </member>
        <member name="M:PCRE.PcreRefMatch.ToString">
            <inheritdoc cref="M:PCRE.PcreMatch.ToString"/>
        </member>
        <member name="T:PCRE.PcreRefMatch.GroupList">
            <summary>
            The list of groups in a match.
            </summary>
        </member>
        <member name="P:PCRE.PcreRefMatch.GroupList.Count">
            <summary>
            Returns the capture count.
            </summary>
        </member>
        <member name="M:PCRE.PcreRefMatch.GroupList.GetEnumerator">
            <inheritdoc cref="M:System.Collections.Generic.IEnumerable`1.GetEnumerator"/>
        </member>
        <member name="P:PCRE.PcreRefMatch.GroupList.Item(System.Int32)">
            <inheritdoc cref="M:PCRE.PcreMatch.get_Item(System.Int32)"/>
        </member>
        <member name="P:PCRE.PcreRefMatch.GroupList.Item(System.String)">
            <inheritdoc cref="M:PCRE.PcreMatch.get_Item(System.String)"/>
        </member>
        <member name="M:PCRE.PcreRefMatch.GroupList.ToList``1(PCRE.PcreRefGroup.Func{``0})">
            <summary>
            Creates a <see cref="T:System.Collections.Generic.List`1"/> out of the groups by applying a <paramref name="selector"/> method.
            </summary>
            <param name="selector">The selector that converts a group to a list item.</param>
            <typeparam name="T">The type of list items.</typeparam>
        </member>
        <member name="T:PCRE.PcreRefMatch.GroupEnumerator">
            <summary>
            A capturing group enumerator.
            </summary>
        </member>
        <member name="P:PCRE.PcreRefMatch.GroupEnumerator.Current">
            <inheritdoc cref="P:System.Collections.Generic.IEnumerator`1.Current"/>
        </member>
        <member name="M:PCRE.PcreRefMatch.GroupEnumerator.MoveNext">
            <inheritdoc cref="M:System.Collections.IEnumerator.MoveNext"/>
        </member>
        <member name="T:PCRE.PcreRefMatch.DuplicateNamedGroupEnumerable">
            <summary>
            An enumerable of duplicated named groups.
            </summary>
        </member>
        <member name="M:PCRE.PcreRefMatch.DuplicateNamedGroupEnumerable.GetEnumerator">
            <inheritdoc cref="M:System.Collections.Generic.IEnumerable`1.GetEnumerator"/>
        </member>
        <member name="M:PCRE.PcreRefMatch.DuplicateNamedGroupEnumerable.ToList``1(PCRE.PcreRefGroup.Func{``0})">
            <summary>
            Creates a <see cref="T:System.Collections.Generic.List`1"/> out of the groups by applying a <paramref name="selector"/> method.
            </summary>
            <param name="selector">The selector that converts a group to a list item.</param>
            <typeparam name="T">The type of list items.</typeparam>
        </member>
        <member name="T:PCRE.PcreRefMatch.DuplicateNamedGroupEnumerator">
            <summary>
            An enumerator of duplicated named groups.
            </summary>
        </member>
        <member name="P:PCRE.PcreRefMatch.DuplicateNamedGroupEnumerator.Current">
            <inheritdoc cref="P:System.Collections.Generic.IEnumerator`1.Current"/>
        </member>
        <member name="M:PCRE.PcreRefMatch.DuplicateNamedGroupEnumerator.MoveNext">
            <inheritdoc cref="M:System.Collections.IEnumerator.MoveNext"/>
        </member>
        <member name="T:PCRE.PcreRegex">
            <summary>
            A PCRE regular expression.
            </summary>
        </member>
        <member name="P:PCRE.PcreRegex.PatternInfo">
            <summary>
            Returns information about the pattern.
            </summary>
        </member>
        <member name="P:PCRE.PcreRegex.CacheSize">
            <summary>
            The size of the internal caches.
            </summary>
            <remarks>
            The cache is used for the following items:
            <list type="bullet">
            <item>Regex patterns: each instantiation of <see cref="T:PCRE.PcreRegex"/> or usage of the static matching methods tries to find the pattern in the cache before compiling it.</item>
            <item>Replacement strings: recently used replacement strings are not parsed if available in the cache.</item>
            </list>
            Set this to 0 to disable the cache.
            </remarks>
        </member>
        <member name="P:PCRE.PcreRegex.Dfa">
            <summary>
            Gives access to the DFA (deterministic finite automaton) matching API.
            </summary>
        </member>
        <member name="M:PCRE.PcreRegex.#ctor(System.String)">
            <summary>
            Creates a PCRE regex.
            </summary>
            <param name="pattern">The regular expression pattern.</param>
        </member>
        <member name="M:PCRE.PcreRegex.#ctor(System.String,PCRE.PcreOptions)">
            <summary>
            Creates a PCRE regex.
            </summary>
            <param name="pattern">The regular expression pattern.</param>
            <param name="options">Pattern options.</param>
        </member>
        <member name="M:PCRE.PcreRegex.#ctor(System.String,PCRE.PcreRegexSettings)">
            <summary>
            Creates a PCRE regex.
            </summary>
            <param name="pattern">The regular expression pattern.</param>
            <param name="settings">Additional advanced settings.</param>
        </member>
        <member name="M:PCRE.PcreRegex.CreateMatchBuffer">
            <summary>
            Creates a buffer for zero-allocation matching.
            </summary>
            <remarks>
            The resulting <see cref="T:PCRE.PcreMatchBuffer"/> can be used to perform match operations without allocating any managed memory,
            therefore not inducing any GC pressure. Note that the buffer is not thread-safe and not reentrant.
            </remarks>
        </member>
        <member name="M:PCRE.PcreRegex.CreateMatchBuffer(PCRE.PcreMatchSettings)">
            <inheritdoc cref="M:PCRE.PcreRegex.CreateMatchBuffer"/>
            <param name="settings">Additional settings.</param>
        </member>
        <member name="M:PCRE.PcreRegex.ToString">
            <summary>
            Returns the regex pattern.
            </summary>
        </member>
        <member name="M:PCRE.PcreRegex.IsMatch(System.String)">
            <summary>
      Indicates whether the regex matches the given subject.
    </summary>
            <param name="subject">The subject string to be matched.</param>
        </member>
        <member name="M:PCRE.PcreRegex.IsMatch(System.ReadOnlySpan{System.Char})">
            <summary>
      Indicates whether the regex matches the given subject.
    </summary>
            <param name="subject">The subject string to be matched.</param>
        </member>
        <member name="M:PCRE.PcreRegex.IsMatch(System.String,System.Int32)">
            <summary>
      Indicates whether the regex matches the given subject.
    </summary>
            <param name="subject">The subject string to be matched.</param><param name="startIndex">The index at which the match should be attempted.</param>
            <remarks>
            <para>
      Passing a non-zero
      <paramref name="startIndex" />
      differs from passing a shortened string if the pattern
      starts with an assertion (such as <c>\b</c>) or contains lookbehinds.
    </para>
            </remarks>
        </member>
        <member name="M:PCRE.PcreRegex.IsMatch(System.ReadOnlySpan{System.Char},System.Int32)">
            <summary>
      Indicates whether the regex matches the given subject.
    </summary>
            <param name="subject">The subject string to be matched.</param><param name="startIndex">The index at which the match should be attempted.</param>
            <remarks>
            <para>
      Passing a non-zero
      <paramref name="startIndex" />
      differs from passing a shortened string if the pattern
      starts with an assertion (such as <c>\b</c>) or contains lookbehinds.
    </para>
            </remarks>
        </member>
        <member name="M:PCRE.PcreRegex.Match(System.String)">
            <summary>
      Matches the regex against the given subject.
    </summary>
            <param name="subject">The subject string to be matched.</param>
        </member>
        <member name="M:PCRE.PcreRegex.Match(System.ReadOnlySpan{System.Char})">
            <summary>
      Matches the regex against the given subject.
    </summary>
            <param name="subject">The subject string to be matched.</param>
        </member>
        <member name="M:PCRE.PcreRegex.Match(System.String,PCRE.PcreMatchOptions)">
            <summary>
      Matches the regex against the given subject.
    </summary>
            <param name="subject">The subject string to be matched.</param><param name="options">Additional options.</param>
        </member>
        <member name="M:PCRE.PcreRegex.Match(System.ReadOnlySpan{System.Char},PCRE.PcreMatchOptions)">
            <summary>
      Matches the regex against the given subject.
    </summary>
            <param name="subject">The subject string to be matched.</param><param name="options">Additional options.</param>
        </member>
        <member name="M:PCRE.PcreRegex.Match(System.String,System.Int32)">
            <summary>
      Matches the regex against the given subject.
    </summary>
            <param name="subject">The subject string to be matched.</param><param name="startIndex">The index at which the match should be attempted.</param>
            <remarks>
            <para>
      Passing a non-zero
      <paramref name="startIndex" />
      differs from passing a shortened string if the pattern
      starts with an assertion (such as <c>\b</c>) or contains lookbehinds.
    </para>
            </remarks>
        </member>
        <member name="M:PCRE.PcreRegex.Match(System.ReadOnlySpan{System.Char},System.Int32)">
            <summary>
      Matches the regex against the given subject.
    </summary>
            <param name="subject">The subject string to be matched.</param><param name="startIndex">The index at which the match should be attempted.</param>
            <remarks>
            <para>
      Passing a non-zero
      <paramref name="startIndex" />
      differs from passing a shortened string if the pattern
      starts with an assertion (such as <c>\b</c>) or contains lookbehinds.
    </para>
            </remarks>
        </member>
        <member name="M:PCRE.PcreRegex.Match(System.String,System.Int32,PCRE.PcreMatchOptions)">
            <summary>
      Matches the regex against the given subject.
    </summary>
            <param name="subject">The subject string to be matched.</param><param name="startIndex">The index at which the match should be attempted.</param><param name="options">Additional options.</param>
            <remarks>
            <para>
      Passing a non-zero
      <paramref name="startIndex" />
      differs from passing a shortened string if the pattern
      starts with an assertion (such as <c>\b</c>) or contains lookbehinds.
    </para>
            </remarks>
        </member>
        <member name="M:PCRE.PcreRegex.Match(System.ReadOnlySpan{System.Char},System.Int32,PCRE.PcreMatchOptions)">
            <summary>
      Matches the regex against the given subject.
    </summary>
            <param name="subject">The subject string to be matched.</param><param name="startIndex">The index at which the match should be attempted.</param><param name="options">Additional options.</param>
            <remarks>
            <para>
      Passing a non-zero
      <paramref name="startIndex" />
      differs from passing a shortened string if the pattern
      starts with an assertion (such as <c>\b</c>) or contains lookbehinds.
    </para>
            </remarks>
        </member>
        <member name="M:PCRE.PcreRegex.Match(System.String,System.Func{PCRE.PcreCallout,PCRE.PcreCalloutResult})">
            <summary>
      Matches the regex against the given subject.
    </summary>
            <param name="subject">The subject string to be matched.</param><param name="onCallout">A function to be called when a callout point is reached during the match.</param>
            <remarks>
            <para>
      Within a regular expression, <c>(?C&lt;arg&gt;)</c> indicates a point at which the external function is to be called.
      Different callout points can be identified by putting a number less than 256 after the letter C. The default value is zero.
      Alternatively, the argument may be a delimited string. The starting delimiter must be one of
      <c>` ' " ^ % # $ {</c>
      and the ending delimiter is the same as the start, except for <c>{</c>, where the ending delimiter is <c>}</c>.
      If the
      <see cref="F:PCRE.PcreOptions.AutoCallout" />
      option bit is set when a pattern is compiled, PCRE2 automatically inserts callouts,
      all with number 255, before each item in the pattern except for immediately before or after an explicit callout.
    </para>
            </remarks>
        </member>
        <member name="M:PCRE.PcreRegex.Match(System.ReadOnlySpan{System.Char},PCRE.PcreRefCalloutFunc)">
            <summary>
      Matches the regex against the given subject.
    </summary>
            <param name="subject">The subject string to be matched.</param><param name="onCallout">A function to be called when a callout point is reached during the match.</param>
            <remarks>
            <para>
      Within a regular expression, <c>(?C&lt;arg&gt;)</c> indicates a point at which the external function is to be called.
      Different callout points can be identified by putting a number less than 256 after the letter C. The default value is zero.
      Alternatively, the argument may be a delimited string. The starting delimiter must be one of
      <c>` ' " ^ % # $ {</c>
      and the ending delimiter is the same as the start, except for <c>{</c>, where the ending delimiter is <c>}</c>.
      If the
      <see cref="F:PCRE.PcreOptions.AutoCallout" />
      option bit is set when a pattern is compiled, PCRE2 automatically inserts callouts,
      all with number 255, before each item in the pattern except for immediately before or after an explicit callout.
    </para>
            </remarks>
        </member>
        <member name="M:PCRE.PcreRegex.Match(System.String,PCRE.PcreMatchOptions,System.Func{PCRE.PcreCallout,PCRE.PcreCalloutResult})">
            <summary>
      Matches the regex against the given subject.
    </summary>
            <param name="subject">The subject string to be matched.</param><param name="options">Additional options.</param><param name="onCallout">A function to be called when a callout point is reached during the match.</param>
            <remarks>
            <para>
      Within a regular expression, <c>(?C&lt;arg&gt;)</c> indicates a point at which the external function is to be called.
      Different callout points can be identified by putting a number less than 256 after the letter C. The default value is zero.
      Alternatively, the argument may be a delimited string. The starting delimiter must be one of
      <c>` ' " ^ % # $ {</c>
      and the ending delimiter is the same as the start, except for <c>{</c>, where the ending delimiter is <c>}</c>.
      If the
      <see cref="F:PCRE.PcreOptions.AutoCallout" />
      option bit is set when a pattern is compiled, PCRE2 automatically inserts callouts,
      all with number 255, before each item in the pattern except for immediately before or after an explicit callout.
    </para>
            </remarks>
        </member>
        <member name="M:PCRE.PcreRegex.Match(System.ReadOnlySpan{System.Char},PCRE.PcreMatchOptions,PCRE.PcreRefCalloutFunc)">
            <summary>
      Matches the regex against the given subject.
    </summary>
            <param name="subject">The subject string to be matched.</param><param name="options">Additional options.</param><param name="onCallout">A function to be called when a callout point is reached during the match.</param>
            <remarks>
            <para>
      Within a regular expression, <c>(?C&lt;arg&gt;)</c> indicates a point at which the external function is to be called.
      Different callout points can be identified by putting a number less than 256 after the letter C. The default value is zero.
      Alternatively, the argument may be a delimited string. The starting delimiter must be one of
      <c>` ' " ^ % # $ {</c>
      and the ending delimiter is the same as the start, except for <c>{</c>, where the ending delimiter is <c>}</c>.
      If the
      <see cref="F:PCRE.PcreOptions.AutoCallout" />
      option bit is set when a pattern is compiled, PCRE2 automatically inserts callouts,
      all with number 255, before each item in the pattern except for immediately before or after an explicit callout.
    </para>
            </remarks>
        </member>
        <member name="M:PCRE.PcreRegex.Match(System.String,System.Int32,System.Func{PCRE.PcreCallout,PCRE.PcreCalloutResult})">
            <summary>
      Matches the regex against the given subject.
    </summary>
            <param name="subject">The subject string to be matched.</param><param name="startIndex">The index at which the match should be attempted.</param><param name="onCallout">A function to be called when a callout point is reached during the match.</param>
            <remarks>
            <para>
      Within a regular expression, <c>(?C&lt;arg&gt;)</c> indicates a point at which the external function is to be called.
      Different callout points can be identified by putting a number less than 256 after the letter C. The default value is zero.
      Alternatively, the argument may be a delimited string. The starting delimiter must be one of
      <c>` ' " ^ % # $ {</c>
      and the ending delimiter is the same as the start, except for <c>{</c>, where the ending delimiter is <c>}</c>.
      If the
      <see cref="F:PCRE.PcreOptions.AutoCallout" />
      option bit is set when a pattern is compiled, PCRE2 automatically inserts callouts,
      all with number 255, before each item in the pattern except for immediately before or after an explicit callout.
    </para><para>
      Passing a non-zero
      <paramref name="startIndex" />
      differs from passing a shortened string if the pattern
      starts with an assertion (such as <c>\b</c>) or contains lookbehinds.
    </para>
            </remarks>
        </member>
        <member name="M:PCRE.PcreRegex.Match(System.ReadOnlySpan{System.Char},System.Int32,PCRE.PcreRefCalloutFunc)">
            <summary>
      Matches the regex against the given subject.
    </summary>
            <param name="subject">The subject string to be matched.</param><param name="startIndex">The index at which the match should be attempted.</param><param name="onCallout">A function to be called when a callout point is reached during the match.</param>
            <remarks>
            <para>
      Within a regular expression, <c>(?C&lt;arg&gt;)</c> indicates a point at which the external function is to be called.
      Different callout points can be identified by putting a number less than 256 after the letter C. The default value is zero.
      Alternatively, the argument may be a delimited string. The starting delimiter must be one of
      <c>` ' " ^ % # $ {</c>
      and the ending delimiter is the same as the start, except for <c>{</c>, where the ending delimiter is <c>}</c>.
      If the
      <see cref="F:PCRE.PcreOptions.AutoCallout" />
      option bit is set when a pattern is compiled, PCRE2 automatically inserts callouts,
      all with number 255, before each item in the pattern except for immediately before or after an explicit callout.
    </para><para>
      Passing a non-zero
      <paramref name="startIndex" />
      differs from passing a shortened string if the pattern
      starts with an assertion (such as <c>\b</c>) or contains lookbehinds.
    </para>
            </remarks>
        </member>
        <member name="M:PCRE.PcreRegex.Match(System.String,System.Int32,PCRE.PcreMatchOptions,System.Func{PCRE.PcreCallout,PCRE.PcreCalloutResult})">
            <summary>
      Matches the regex against the given subject.
    </summary>
            <param name="subject">The subject string to be matched.</param><param name="startIndex">The index at which the match should be attempted.</param><param name="options">Additional options.</param><param name="onCallout">A function to be called when a callout point is reached during the match.</param>
            <remarks>
            <para>
      Within a regular expression, <c>(?C&lt;arg&gt;)</c> indicates a point at which the external function is to be called.
      Different callout points can be identified by putting a number less than 256 after the letter C. The default value is zero.
      Alternatively, the argument may be a delimited string. The starting delimiter must be one of
      <c>` ' " ^ % # $ {</c>
      and the ending delimiter is the same as the start, except for <c>{</c>, where the ending delimiter is <c>}</c>.
      If the
      <see cref="F:PCRE.PcreOptions.AutoCallout" />
      option bit is set when a pattern is compiled, PCRE2 automatically inserts callouts,
      all with number 255, before each item in the pattern except for immediately before or after an explicit callout.
    </para><para>
      Passing a non-zero
      <paramref name="startIndex" />
      differs from passing a shortened string if the pattern
      starts with an assertion (such as <c>\b</c>) or contains lookbehinds.
    </para>
            </remarks>
        </member>
        <member name="M:PCRE.PcreRegex.Match(System.ReadOnlySpan{System.Char},System.Int32,PCRE.PcreMatchOptions,PCRE.PcreRefCalloutFunc)">
            <summary>
      Matches the regex against the given subject.
    </summary>
            <param name="subject">The subject string to be matched.</param><param name="startIndex">The index at which the match should be attempted.</param><param name="options">Additional options.</param><param name="onCallout">A function to be called when a callout point is reached during the match.</param>
            <remarks>
            <para>
      Within a regular expression, <c>(?C&lt;arg&gt;)</c> indicates a point at which the external function is to be called.
      Different callout points can be identified by putting a number less than 256 after the letter C. The default value is zero.
      Alternatively, the argument may be a delimited string. The starting delimiter must be one of
      <c>` ' " ^ % # $ {</c>
      and the ending delimiter is the same as the start, except for <c>{</c>, where the ending delimiter is <c>}</c>.
      If the
      <see cref="F:PCRE.PcreOptions.AutoCallout" />
      option bit is set when a pattern is compiled, PCRE2 automatically inserts callouts,
      all with number 255, before each item in the pattern except for immediately before or after an explicit callout.
    </para><para>
      Passing a non-zero
      <paramref name="startIndex" />
      differs from passing a shortened string if the pattern
      starts with an assertion (such as <c>\b</c>) or contains lookbehinds.
    </para>
            </remarks>
        </member>
        <member name="M:PCRE.PcreRegex.Match(System.String,System.Int32,PCRE.PcreMatchOptions,System.Func{PCRE.PcreCallout,PCRE.PcreCalloutResult},PCRE.PcreMatchSettings)">
            <summary>
      Matches the regex against the given subject.
    </summary>
            <param name="subject">The subject string to be matched.</param><param name="startIndex">The index at which the match should be attempted.</param><param name="options">Additional options.</param><param name="onCallout">A function to be called when a callout point is reached during the match.</param><param name="settings">Additional advanced settings.</param>
            <remarks>
            <para>
      Within a regular expression, <c>(?C&lt;arg&gt;)</c> indicates a point at which the external function is to be called.
      Different callout points can be identified by putting a number less than 256 after the letter C. The default value is zero.
      Alternatively, the argument may be a delimited string. The starting delimiter must be one of
      <c>` ' " ^ % # $ {</c>
      and the ending delimiter is the same as the start, except for <c>{</c>, where the ending delimiter is <c>}</c>.
      If the
      <see cref="F:PCRE.PcreOptions.AutoCallout" />
      option bit is set when a pattern is compiled, PCRE2 automatically inserts callouts,
      all with number 255, before each item in the pattern except for immediately before or after an explicit callout.
    </para><para>
      Passing a non-zero
      <paramref name="startIndex" />
      differs from passing a shortened string if the pattern
      starts with an assertion (such as <c>\b</c>) or contains lookbehinds.
    </para>
            </remarks>
        </member>
        <member name="M:PCRE.PcreRegex.Match(System.ReadOnlySpan{System.Char},System.Int32,PCRE.PcreMatchOptions,PCRE.PcreRefCalloutFunc,PCRE.PcreMatchSettings)">
            <summary>
      Matches the regex against the given subject.
    </summary>
            <param name="subject">The subject string to be matched.</param><param name="startIndex">The index at which the match should be attempted.</param><param name="options">Additional options.</param><param name="onCallout">A function to be called when a callout point is reached during the match.</param><param name="settings">Additional advanced settings.</param>
            <remarks>
            <para>
      Within a regular expression, <c>(?C&lt;arg&gt;)</c> indicates a point at which the external function is to be called.
      Different callout points can be identified by putting a number less than 256 after the letter C. The default value is zero.
      Alternatively, the argument may be a delimited string. The starting delimiter must be one of
      <c>` ' " ^ % # $ {</c>
      and the ending delimiter is the same as the start, except for <c>{</c>, where the ending delimiter is <c>}</c>.
      If the
      <see cref="F:PCRE.PcreOptions.AutoCallout" />
      option bit is set when a pattern is compiled, PCRE2 automatically inserts callouts,
      all with number 255, before each item in the pattern except for immediately before or after an explicit callout.
    </para><para>
      Passing a non-zero
      <paramref name="startIndex" />
      differs from passing a shortened string if the pattern
      starts with an assertion (such as <c>\b</c>) or contains lookbehinds.
    </para>
            </remarks>
        </member>
        <member name="M:PCRE.PcreRegex.Matches(System.String)">
            <summary>
      Returns an enumerable of all matches found in the given subject.
    </summary>
            <param name="subject">The subject string to be matched.</param>
        </member>
        <member name="M:PCRE.PcreRegex.Matches(System.ReadOnlySpan{System.Char})">
            <summary>
      Returns an enumerable of all matches found in the given subject.
    </summary>
            <param name="subject">The subject string to be matched.</param>
        </member>
        <member name="M:PCRE.PcreRegex.Matches(System.String,System.Int32)">
            <summary>
      Returns an enumerable of all matches found in the given subject.
    </summary>
            <param name="subject">The subject string to be matched.</param><param name="startIndex">The index at which the match should be attempted.</param>
            <remarks>
            <para>
      Passing a non-zero
      <paramref name="startIndex" />
      differs from passing a shortened string if the pattern
      starts with an assertion (such as <c>\b</c>) or contains lookbehinds.
    </para>
            </remarks>
        </member>
        <member name="M:PCRE.PcreRegex.Matches(System.ReadOnlySpan{System.Char},System.Int32)">
            <summary>
      Returns an enumerable of all matches found in the given subject.
    </summary>
            <param name="subject">The subject string to be matched.</param><param name="startIndex">The index at which the match should be attempted.</param>
            <remarks>
            <para>
      Passing a non-zero
      <paramref name="startIndex" />
      differs from passing a shortened string if the pattern
      starts with an assertion (such as <c>\b</c>) or contains lookbehinds.
    </para>
            </remarks>
        </member>
        <member name="M:PCRE.PcreRegex.Matches(System.String,System.Int32,System.Func{PCRE.PcreCallout,PCRE.PcreCalloutResult})">
            <summary>
      Returns an enumerable of all matches found in the given subject.
    </summary>
            <param name="subject">The subject string to be matched.</param><param name="startIndex">The index at which the match should be attempted.</param><param name="onCallout">A function to be called when a callout point is reached during the match.</param>
            <remarks>
            <para>
      Within a regular expression, <c>(?C&lt;arg&gt;)</c> indicates a point at which the external function is to be called.
      Different callout points can be identified by putting a number less than 256 after the letter C. The default value is zero.
      Alternatively, the argument may be a delimited string. The starting delimiter must be one of
      <c>` ' " ^ % # $ {</c>
      and the ending delimiter is the same as the start, except for <c>{</c>, where the ending delimiter is <c>}</c>.
      If the
      <see cref="F:PCRE.PcreOptions.AutoCallout" />
      option bit is set when a pattern is compiled, PCRE2 automatically inserts callouts,
      all with number 255, before each item in the pattern except for immediately before or after an explicit callout.
    </para><para>
      Passing a non-zero
      <paramref name="startIndex" />
      differs from passing a shortened string if the pattern
      starts with an assertion (such as <c>\b</c>) or contains lookbehinds.
    </para>
            </remarks>
        </member>
        <member name="M:PCRE.PcreRegex.Matches(System.ReadOnlySpan{System.Char},System.Int32,PCRE.PcreRefCalloutFunc)">
            <summary>
      Returns an enumerable of all matches found in the given subject.
    </summary>
            <param name="subject">The subject string to be matched.</param><param name="startIndex">The index at which the match should be attempted.</param><param name="onCallout">A function to be called when a callout point is reached during the match.</param>
            <remarks>
            <para>
      Within a regular expression, <c>(?C&lt;arg&gt;)</c> indicates a point at which the external function is to be called.
      Different callout points can be identified by putting a number less than 256 after the letter C. The default value is zero.
      Alternatively, the argument may be a delimited string. The starting delimiter must be one of
      <c>` ' " ^ % # $ {</c>
      and the ending delimiter is the same as the start, except for <c>{</c>, where the ending delimiter is <c>}</c>.
      If the
      <see cref="F:PCRE.PcreOptions.AutoCallout" />
      option bit is set when a pattern is compiled, PCRE2 automatically inserts callouts,
      all with number 255, before each item in the pattern except for immediately before or after an explicit callout.
    </para><para>
      Passing a non-zero
      <paramref name="startIndex" />
      differs from passing a shortened string if the pattern
      starts with an assertion (such as <c>\b</c>) or contains lookbehinds.
    </para>
            </remarks>
        </member>
        <member name="M:PCRE.PcreRegex.Matches(System.String,System.Int32,PCRE.PcreMatchOptions,System.Func{PCRE.PcreCallout,PCRE.PcreCalloutResult},PCRE.PcreMatchSettings)">
            <summary>
      Returns an enumerable of all matches found in the given subject.
    </summary>
            <param name="subject">The subject string to be matched.</param><param name="startIndex">The index at which the match should be attempted.</param><param name="options">Additional options.</param><param name="onCallout">A function to be called when a callout point is reached during the match.</param><param name="settings">Additional advanced settings.</param>
            <remarks>
            <para>
      Within a regular expression, <c>(?C&lt;arg&gt;)</c> indicates a point at which the external function is to be called.
      Different callout points can be identified by putting a number less than 256 after the letter C. The default value is zero.
      Alternatively, the argument may be a delimited string. The starting delimiter must be one of
      <c>` ' " ^ % # $ {</c>
      and the ending delimiter is the same as the start, except for <c>{</c>, where the ending delimiter is <c>}</c>.
      If the
      <see cref="F:PCRE.PcreOptions.AutoCallout" />
      option bit is set when a pattern is compiled, PCRE2 automatically inserts callouts,
      all with number 255, before each item in the pattern except for immediately before or after an explicit callout.
    </para><para>
      Passing a non-zero
      <paramref name="startIndex" />
      differs from passing a shortened string if the pattern
      starts with an assertion (such as <c>\b</c>) or contains lookbehinds.
    </para>
            </remarks>
        </member>
        <member name="M:PCRE.PcreRegex.Matches(System.ReadOnlySpan{System.Char},System.Int32,PCRE.PcreMatchOptions,PCRE.PcreRefCalloutFunc,PCRE.PcreMatchSettings)">
            <summary>
      Returns an enumerable of all matches found in the given subject.
    </summary>
            <param name="subject">The subject string to be matched.</param><param name="startIndex">The index at which the match should be attempted.</param><param name="options">Additional options.</param><param name="onCallout">A function to be called when a callout point is reached during the match.</param><param name="settings">Additional advanced settings.</param>
            <remarks>
            <para>
      Within a regular expression, <c>(?C&lt;arg&gt;)</c> indicates a point at which the external function is to be called.
      Different callout points can be identified by putting a number less than 256 after the letter C. The default value is zero.
      Alternatively, the argument may be a delimited string. The starting delimiter must be one of
      <c>` ' " ^ % # $ {</c>
      and the ending delimiter is the same as the start, except for <c>{</c>, where the ending delimiter is <c>}</c>.
      If the
      <see cref="F:PCRE.PcreOptions.AutoCallout" />
      option bit is set when a pattern is compiled, PCRE2 automatically inserts callouts,
      all with number 255, before each item in the pattern except for immediately before or after an explicit callout.
    </para><para>
      Passing a non-zero
      <paramref name="startIndex" />
      differs from passing a shortened string if the pattern
      starts with an assertion (such as <c>\b</c>) or contains lookbehinds.
    </para>
            </remarks>
        </member>
        <member name="M:PCRE.PcreRegex.IsMatch(System.String,System.String)">
            <summary>
      Indicates whether the regex matches the given subject.
    </summary>
            <param name="subject">The subject string to be matched.</param><param name="pattern">The regular expression pattern.</param>
            <remarks>
            <para>
      Note that using a static matching method is not efficient. For best performance,
      create a
      <see cref="T:PCRE.PcreRegex" />
      object and use its instance methods.
    </para>
            </remarks>
        </member>
        <member name="M:PCRE.PcreRegex.IsMatch(System.String,System.String,PCRE.PcreOptions)">
            <summary>
      Indicates whether the regex matches the given subject.
    </summary>
            <param name="subject">The subject string to be matched.</param><param name="pattern">The regular expression pattern.</param><param name="options">Additional options.</param>
            <remarks>
            <para>
      Note that using a static matching method is not efficient. For best performance,
      create a
      <see cref="T:PCRE.PcreRegex" />
      object and use its instance methods.
    </para>
            </remarks>
        </member>
        <member name="M:PCRE.PcreRegex.IsMatch(System.String,System.String,PCRE.PcreOptions,System.Int32)">
            <summary>
      Indicates whether the regex matches the given subject.
    </summary>
            <param name="subject">The subject string to be matched.</param><param name="pattern">The regular expression pattern.</param><param name="startIndex">The index at which the match should be attempted.</param><param name="options">Additional options.</param>
            <remarks>
            <para>
      Note that using a static matching method is not efficient. For best performance,
      create a
      <see cref="T:PCRE.PcreRegex" />
      object and use its instance methods.
    </para><para>
      Passing a non-zero
      <paramref name="startIndex" />
      differs from passing a shortened string if the pattern
      starts with an assertion (such as <c>\b</c>) or contains lookbehinds.
    </para>
            </remarks>
        </member>
        <member name="M:PCRE.PcreRegex.Match(System.String,System.String)">
            <summary>
      Matches the regex against the given subject.
    </summary>
            <param name="subject">The subject string to be matched.</param><param name="pattern">The regular expression pattern.</param>
            <remarks>
            <para>
      Note that using a static matching method is not efficient. For best performance,
      create a
      <see cref="T:PCRE.PcreRegex" />
      object and use its instance methods.
    </para>
            </remarks>
        </member>
        <member name="M:PCRE.PcreRegex.Match(System.String,System.String,PCRE.PcreOptions)">
            <summary>
      Matches the regex against the given subject.
    </summary>
            <param name="subject">The subject string to be matched.</param><param name="pattern">The regular expression pattern.</param><param name="options">Additional options.</param>
            <remarks>
            <para>
      Note that using a static matching method is not efficient. For best performance,
      create a
      <see cref="T:PCRE.PcreRegex" />
      object and use its instance methods.
    </para>
            </remarks>
        </member>
        <member name="M:PCRE.PcreRegex.Match(System.String,System.String,PCRE.PcreOptions,System.Int32)">
            <summary>
      Matches the regex against the given subject.
    </summary>
            <param name="subject">The subject string to be matched.</param><param name="pattern">The regular expression pattern.</param><param name="startIndex">The index at which the match should be attempted.</param><param name="options">Additional options.</param>
            <remarks>
            <para>
      Note that using a static matching method is not efficient. For best performance,
      create a
      <see cref="T:PCRE.PcreRegex" />
      object and use its instance methods.
    </para><para>
      Passing a non-zero
      <paramref name="startIndex" />
      differs from passing a shortened string if the pattern
      starts with an assertion (such as <c>\b</c>) or contains lookbehinds.
    </para>
            </remarks>
        </member>
        <member name="M:PCRE.PcreRegex.Matches(System.String,System.String)">
            <summary>
      Returns an enumerable of all matches found in the given subject.
    </summary>
            <param name="subject">The subject string to be matched.</param><param name="pattern">The regular expression pattern.</param>
            <remarks>
            <para>
      Note that using a static matching method is not efficient. For best performance,
      create a
      <see cref="T:PCRE.PcreRegex" />
      object and use its instance methods.
    </para>
            </remarks>
        </member>
        <member name="M:PCRE.PcreRegex.Matches(System.String,System.String,PCRE.PcreOptions)">
            <summary>
      Returns an enumerable of all matches found in the given subject.
    </summary>
            <param name="subject">The subject string to be matched.</param><param name="pattern">The regular expression pattern.</param><param name="options">Additional options.</param>
            <remarks>
            <para>
      Note that using a static matching method is not efficient. For best performance,
      create a
      <see cref="T:PCRE.PcreRegex" />
      object and use its instance methods.
    </para>
            </remarks>
        </member>
        <member name="M:PCRE.PcreRegex.Matches(System.String,System.String,PCRE.PcreOptions,System.Int32)">
            <summary>
      Returns an enumerable of all matches found in the given subject.
    </summary>
            <param name="subject">The subject string to be matched.</param><param name="pattern">The regular expression pattern.</param><param name="startIndex">The index at which the match should be attempted.</param><param name="options">Additional options.</param>
            <remarks>
            <para>
      Note that using a static matching method is not efficient. For best performance,
      create a
      <see cref="T:PCRE.PcreRegex" />
      object and use its instance methods.
    </para><para>
      Passing a non-zero
      <paramref name="startIndex" />
      differs from passing a shortened string if the pattern
      starts with an assertion (such as <c>\b</c>) or contains lookbehinds.
    </para>
            </remarks>
        </member>
        <member name="T:PCRE.PcreRegex.RefMatchEnumerable">
            <summary>
            An enumerable of matches against a <see cref="T:System.ReadOnlySpan`1"/>.
            </summary>
        </member>
        <member name="M:PCRE.PcreRegex.RefMatchEnumerable.GetEnumerator">
            <inheritdoc cref="M:System.Collections.Generic.IEnumerable`1.GetEnumerator"/>
        </member>
        <member name="M:PCRE.PcreRegex.RefMatchEnumerable.ToList``1(PCRE.PcreRefMatch.Func{``0})">
            <summary>
            Creates a <see cref="T:System.Collections.Generic.List`1"/> out of the matches by applying a <paramref name="selector"/> method.
            </summary>
            <param name="selector">The selector that converts a match to a list item.</param>
            <typeparam name="T">The type of list items.</typeparam>
        </member>
        <member name="T:PCRE.PcreRegex.RefMatchEnumerator">
            <summary>
            An enumerator of matches against a <see cref="T:System.ReadOnlySpan`1"/>.
            </summary>
        </member>
        <member name="P:PCRE.PcreRegex.RefMatchEnumerator.Current">
            <summary>
            Gets the current match.
            </summary>
        </member>
        <member name="M:PCRE.PcreRegex.RefMatchEnumerator.MoveNext">
            <summary>
            Moves to the next match.
            </summary>
        </member>
        <member name="M:PCRE.PcreRegex.Replace(System.String,System.String)">
            <summary>
      Replaces matches found in the given subject string.
    </summary>
            <param name="subject">The subject string to be matched.</param><param name="replacement">The replacement string.</param>
            <remarks>
            <para>
      The supported placeholders in the replacement string are similar to those supported by the
      <see cref="T:System.Text.RegularExpressions.Regex" />
      class:
      <list type="bullet">
        <item>
          <c>$n</c>
          - The value of the capture group at index <c>n</c>.
        </item>
        <item>
          <c>${name}</c>
          - The value of the named capture group.
        </item>
        <item>
          <c>$&amp;</c>
          - The value of the full match. Equivalent to <c>$0</c>.
        </item>
        <item>
          <c>$_</c>
          - The full subject string.
        </item>
        <item>
          <c>$`</c>
          - The part of the subject string appearing before the match.
        </item>
        <item>
          <c>$'</c>
          - The part of the subject string appearing after the match.
        </item>
        <item>
          <c>$+</c>
          - The value of the last matched capture group.
        </item>
        <item>
          <c>$$</c>
          - A literal dollar sign.
        </item>
      </list>
    </para>
            </remarks>
        </member>
        <member name="M:PCRE.PcreRegex.Replace(System.String,System.String,System.Int32)">
            <summary>
      Replaces matches found in the given subject string.
    </summary>
            <param name="subject">The subject string to be matched.</param><param name="replacement">The replacement string.</param><param name="count">The maximum number of matches to attempt.</param>
            <remarks>
            <para>
      The supported placeholders in the replacement string are similar to those supported by the
      <see cref="T:System.Text.RegularExpressions.Regex" />
      class:
      <list type="bullet">
        <item>
          <c>$n</c>
          - The value of the capture group at index <c>n</c>.
        </item>
        <item>
          <c>${name}</c>
          - The value of the named capture group.
        </item>
        <item>
          <c>$&amp;</c>
          - The value of the full match. Equivalent to <c>$0</c>.
        </item>
        <item>
          <c>$_</c>
          - The full subject string.
        </item>
        <item>
          <c>$`</c>
          - The part of the subject string appearing before the match.
        </item>
        <item>
          <c>$'</c>
          - The part of the subject string appearing after the match.
        </item>
        <item>
          <c>$+</c>
          - The value of the last matched capture group.
        </item>
        <item>
          <c>$$</c>
          - A literal dollar sign.
        </item>
      </list>
    </para>
            </remarks>
        </member>
        <member name="M:PCRE.PcreRegex.Replace(System.String,System.String,System.Int32,System.Int32)">
            <summary>
      Replaces matches found in the given subject string.
    </summary>
            <param name="subject">The subject string to be matched.</param><param name="replacement">The replacement string.</param><param name="count">The maximum number of matches to attempt.</param><param name="startIndex">The index at which the match should be attempted.</param>
            <remarks>
            <para>
      The supported placeholders in the replacement string are similar to those supported by the
      <see cref="T:System.Text.RegularExpressions.Regex" />
      class:
      <list type="bullet">
        <item>
          <c>$n</c>
          - The value of the capture group at index <c>n</c>.
        </item>
        <item>
          <c>${name}</c>
          - The value of the named capture group.
        </item>
        <item>
          <c>$&amp;</c>
          - The value of the full match. Equivalent to <c>$0</c>.
        </item>
        <item>
          <c>$_</c>
          - The full subject string.
        </item>
        <item>
          <c>$`</c>
          - The part of the subject string appearing before the match.
        </item>
        <item>
          <c>$'</c>
          - The part of the subject string appearing after the match.
        </item>
        <item>
          <c>$+</c>
          - The value of the last matched capture group.
        </item>
        <item>
          <c>$$</c>
          - A literal dollar sign.
        </item>
      </list>
    </para><para>
      Passing a non-zero
      <paramref name="startIndex" />
      differs from passing a shortened string if the pattern
      starts with an assertion (such as <c>\b</c>) or contains lookbehinds.
    </para>
            </remarks>
        </member>
        <member name="M:PCRE.PcreRegex.Replace(System.String,System.Func{PCRE.PcreMatch,System.String})">
            <summary>
      Replaces matches found in the given subject string.
    </summary>
            <param name="subject">The subject string to be matched.</param><param name="replacementFunc">A function called for each match that provides the replacement string.</param>
        </member>
        <member name="M:PCRE.PcreRegex.Replace(System.String,System.Func{PCRE.PcreMatch,System.String},System.Int32)">
            <summary>
      Replaces matches found in the given subject string.
    </summary>
            <param name="subject">The subject string to be matched.</param><param name="replacementFunc">A function called for each match that provides the replacement string.</param><param name="count">The maximum number of matches to attempt.</param>
        </member>
        <member name="M:PCRE.PcreRegex.Replace(System.String,System.Func{PCRE.PcreMatch,System.String},System.Int32,System.Int32)">
            <summary>
      Replaces matches found in the given subject string.
    </summary>
            <param name="subject">The subject string to be matched.</param><param name="replacementFunc">A function called for each match that provides the replacement string.</param><param name="count">The maximum number of matches to attempt.</param><param name="startIndex">The index at which the match should be attempted.</param>
            <remarks>
            <para>
      Passing a non-zero
      <paramref name="startIndex" />
      differs from passing a shortened string if the pattern
      starts with an assertion (such as <c>\b</c>) or contains lookbehinds.
    </para>
            </remarks>
        </member>
        <member name="M:PCRE.PcreRegex.Replace(System.String,System.String,System.String)">
            <summary>
      Replaces matches found in the given subject string.
    </summary>
            <param name="subject">The subject string to be matched.</param><param name="pattern">The regular expression pattern.</param><param name="replacement">The replacement string.</param>
            <remarks>
            <para>
      Note that using a static matching method is not efficient. For best performance,
      create a
      <see cref="T:PCRE.PcreRegex" />
      object and use its instance methods.
    </para><para>
      The supported placeholders in the replacement string are similar to those supported by the
      <see cref="T:System.Text.RegularExpressions.Regex" />
      class:
      <list type="bullet">
        <item>
          <c>$n</c>
          - The value of the capture group at index <c>n</c>.
        </item>
        <item>
          <c>${name}</c>
          - The value of the named capture group.
        </item>
        <item>
          <c>$&amp;</c>
          - The value of the full match. Equivalent to <c>$0</c>.
        </item>
        <item>
          <c>$_</c>
          - The full subject string.
        </item>
        <item>
          <c>$`</c>
          - The part of the subject string appearing before the match.
        </item>
        <item>
          <c>$'</c>
          - The part of the subject string appearing after the match.
        </item>
        <item>
          <c>$+</c>
          - The value of the last matched capture group.
        </item>
        <item>
          <c>$$</c>
          - A literal dollar sign.
        </item>
      </list>
    </para>
            </remarks>
        </member>
        <member name="M:PCRE.PcreRegex.Replace(System.String,System.String,System.String,PCRE.PcreOptions)">
            <summary>
      Replaces matches found in the given subject string.
    </summary>
            <param name="subject">The subject string to be matched.</param><param name="pattern">The regular expression pattern.</param><param name="replacement">The replacement string.</param><param name="options">Additional options.</param>
            <remarks>
            <para>
      Note that using a static matching method is not efficient. For best performance,
      create a
      <see cref="T:PCRE.PcreRegex" />
      object and use its instance methods.
    </para><para>
      The supported placeholders in the replacement string are similar to those supported by the
      <see cref="T:System.Text.RegularExpressions.Regex" />
      class:
      <list type="bullet">
        <item>
          <c>$n</c>
          - The value of the capture group at index <c>n</c>.
        </item>
        <item>
          <c>${name}</c>
          - The value of the named capture group.
        </item>
        <item>
          <c>$&amp;</c>
          - The value of the full match. Equivalent to <c>$0</c>.
        </item>
        <item>
          <c>$_</c>
          - The full subject string.
        </item>
        <item>
          <c>$`</c>
          - The part of the subject string appearing before the match.
        </item>
        <item>
          <c>$'</c>
          - The part of the subject string appearing after the match.
        </item>
        <item>
          <c>$+</c>
          - The value of the last matched capture group.
        </item>
        <item>
          <c>$$</c>
          - A literal dollar sign.
        </item>
      </list>
    </para>
            </remarks>
        </member>
        <member name="M:PCRE.PcreRegex.Replace(System.String,System.String,System.String,PCRE.PcreOptions,System.Int32)">
            <summary>
      Replaces matches found in the given subject string.
    </summary>
            <param name="subject">The subject string to be matched.</param><param name="pattern">The regular expression pattern.</param><param name="replacement">The replacement string.</param><param name="count">The maximum number of matches to attempt.</param><param name="options">Additional options.</param>
            <remarks>
            <para>
      Note that using a static matching method is not efficient. For best performance,
      create a
      <see cref="T:PCRE.PcreRegex" />
      object and use its instance methods.
    </para><para>
      The supported placeholders in the replacement string are similar to those supported by the
      <see cref="T:System.Text.RegularExpressions.Regex" />
      class:
      <list type="bullet">
        <item>
          <c>$n</c>
          - The value of the capture group at index <c>n</c>.
        </item>
        <item>
          <c>${name}</c>
          - The value of the named capture group.
        </item>
        <item>
          <c>$&amp;</c>
          - The value of the full match. Equivalent to <c>$0</c>.
        </item>
        <item>
          <c>$_</c>
          - The full subject string.
        </item>
        <item>
          <c>$`</c>
          - The part of the subject string appearing before the match.
        </item>
        <item>
          <c>$'</c>
          - The part of the subject string appearing after the match.
        </item>
        <item>
          <c>$+</c>
          - The value of the last matched capture group.
        </item>
        <item>
          <c>$$</c>
          - A literal dollar sign.
        </item>
      </list>
    </para>
            </remarks>
        </member>
        <member name="M:PCRE.PcreRegex.Replace(System.String,System.String,System.String,PCRE.PcreOptions,System.Int32,System.Int32)">
            <summary>
      Replaces matches found in the given subject string.
    </summary>
            <param name="subject">The subject string to be matched.</param><param name="pattern">The regular expression pattern.</param><param name="replacement">The replacement string.</param><param name="count">The maximum number of matches to attempt.</param><param name="startIndex">The index at which the match should be attempted.</param><param name="options">Additional options.</param>
            <remarks>
            <para>
      Note that using a static matching method is not efficient. For best performance,
      create a
      <see cref="T:PCRE.PcreRegex" />
      object and use its instance methods.
    </para><para>
      The supported placeholders in the replacement string are similar to those supported by the
      <see cref="T:System.Text.RegularExpressions.Regex" />
      class:
      <list type="bullet">
        <item>
          <c>$n</c>
          - The value of the capture group at index <c>n</c>.
        </item>
        <item>
          <c>${name}</c>
          - The value of the named capture group.
        </item>
        <item>
          <c>$&amp;</c>
          - The value of the full match. Equivalent to <c>$0</c>.
        </item>
        <item>
          <c>$_</c>
          - The full subject string.
        </item>
        <item>
          <c>$`</c>
          - The part of the subject string appearing before the match.
        </item>
        <item>
          <c>$'</c>
          - The part of the subject string appearing after the match.
        </item>
        <item>
          <c>$+</c>
          - The value of the last matched capture group.
        </item>
        <item>
          <c>$$</c>
          - A literal dollar sign.
        </item>
      </list>
    </para><para>
      Passing a non-zero
      <paramref name="startIndex" />
      differs from passing a shortened string if the pattern
      starts with an assertion (such as <c>\b</c>) or contains lookbehinds.
    </para>
            </remarks>
        </member>
        <member name="M:PCRE.PcreRegex.Replace(System.String,System.String,System.Func{PCRE.PcreMatch,System.String})">
            <summary>
      Replaces matches found in the given subject string.
    </summary>
            <param name="subject">The subject string to be matched.</param><param name="pattern">The regular expression pattern.</param><param name="replacementFunc">A function called for each match that provides the replacement string.</param>
            <remarks>
            <para>
      Note that using a static matching method is not efficient. For best performance,
      create a
      <see cref="T:PCRE.PcreRegex" />
      object and use its instance methods.
    </para>
            </remarks>
        </member>
        <member name="M:PCRE.PcreRegex.Replace(System.String,System.String,System.Func{PCRE.PcreMatch,System.String},PCRE.PcreOptions)">
            <summary>
      Replaces matches found in the given subject string.
    </summary>
            <param name="subject">The subject string to be matched.</param><param name="pattern">The regular expression pattern.</param><param name="replacementFunc">A function called for each match that provides the replacement string.</param><param name="options">Additional options.</param>
            <remarks>
            <para>
      Note that using a static matching method is not efficient. For best performance,
      create a
      <see cref="T:PCRE.PcreRegex" />
      object and use its instance methods.
    </para>
            </remarks>
        </member>
        <member name="M:PCRE.PcreRegex.Replace(System.String,System.String,System.Func{PCRE.PcreMatch,System.String},PCRE.PcreOptions,System.Int32)">
            <summary>
      Replaces matches found in the given subject string.
    </summary>
            <param name="subject">The subject string to be matched.</param><param name="pattern">The regular expression pattern.</param><param name="replacementFunc">A function called for each match that provides the replacement string.</param><param name="count">The maximum number of matches to attempt.</param><param name="options">Additional options.</param>
            <remarks>
            <para>
      Note that using a static matching method is not efficient. For best performance,
      create a
      <see cref="T:PCRE.PcreRegex" />
      object and use its instance methods.
    </para>
            </remarks>
        </member>
        <member name="M:PCRE.PcreRegex.Replace(System.String,System.String,System.Func{PCRE.PcreMatch,System.String},PCRE.PcreOptions,System.Int32,System.Int32)">
            <summary>
      Replaces matches found in the given subject string.
    </summary>
            <param name="subject">The subject string to be matched.</param><param name="pattern">The regular expression pattern.</param><param name="replacementFunc">A function called for each match that provides the replacement string.</param><param name="count">The maximum number of matches to attempt.</param><param name="startIndex">The index at which the match should be attempted.</param><param name="options">Additional options.</param>
            <remarks>
            <para>
      Note that using a static matching method is not efficient. For best performance,
      create a
      <see cref="T:PCRE.PcreRegex" />
      object and use its instance methods.
    </para><para>
      Passing a non-zero
      <paramref name="startIndex" />
      differs from passing a shortened string if the pattern
      starts with an assertion (such as <c>\b</c>) or contains lookbehinds.
    </para>
            </remarks>
        </member>
        <member name="M:PCRE.PcreRegex.Split(System.String)">
            <summary>
      Splits a subject string into a sequence of substrings that occur between the matches.
    </summary>
            <param name="subject">The subject string to be matched.</param>
        </member>
        <member name="M:PCRE.PcreRegex.Split(System.String,PCRE.PcreSplitOptions)">
            <summary>
      Splits a subject string into a sequence of substrings that occur between the matches.
    </summary>
            <param name="subject">The subject string to be matched.</param><param name="options">Additional options.</param>
        </member>
        <member name="M:PCRE.PcreRegex.Split(System.String,System.Int32)">
            <summary>
      Splits a subject string into a sequence of substrings that occur between the matches.
    </summary>
            <param name="subject">The subject string to be matched.</param><param name="count">The maximum number of matches to attempt.</param>
        </member>
        <member name="M:PCRE.PcreRegex.Split(System.String,System.Int32,System.Int32)">
            <summary>
      Splits a subject string into a sequence of substrings that occur between the matches.
    </summary>
            <param name="subject">The subject string to be matched.</param><param name="count">The maximum number of matches to attempt.</param><param name="startIndex">The index at which the match should be attempted.</param>
            <remarks>
            <para>
      Passing a non-zero
      <paramref name="startIndex" />
      differs from passing a shortened string if the pattern
      starts with an assertion (such as <c>\b</c>) or contains lookbehinds.
    </para>
            </remarks>
        </member>
        <member name="M:PCRE.PcreRegex.Split(System.String,PCRE.PcreSplitOptions,System.Int32,System.Int32)">
            <summary>
      Splits a subject string into a sequence of substrings that occur between the matches.
    </summary>
            <param name="subject">The subject string to be matched.</param><param name="count">The maximum number of matches to attempt.</param><param name="startIndex">The index at which the match should be attempted.</param><param name="options">Additional options.</param>
            <remarks>
            <para>
      Passing a non-zero
      <paramref name="startIndex" />
      differs from passing a shortened string if the pattern
      starts with an assertion (such as <c>\b</c>) or contains lookbehinds.
    </para>
            </remarks>
        </member>
        <member name="M:PCRE.PcreRegex.Split(System.String,System.String)">
            <summary>
      Splits a subject string into a sequence of substrings that occur between the matches.
    </summary>
            <param name="subject">The subject string to be matched.</param><param name="pattern">The regular expression pattern.</param>
            <remarks>
            <para>
      Note that using a static matching method is not efficient. For best performance,
      create a
      <see cref="T:PCRE.PcreRegex" />
      object and use its instance methods.
    </para>
            </remarks>
        </member>
        <member name="M:PCRE.PcreRegex.Split(System.String,System.String,PCRE.PcreOptions)">
            <summary>
      Splits a subject string into a sequence of substrings that occur between the matches.
    </summary>
            <param name="subject">The subject string to be matched.</param><param name="pattern">The regular expression pattern.</param><param name="options">Additional options.</param>
            <remarks>
            <para>
      Note that using a static matching method is not efficient. For best performance,
      create a
      <see cref="T:PCRE.PcreRegex" />
      object and use its instance methods.
    </para>
            </remarks>
        </member>
        <member name="M:PCRE.PcreRegex.Split(System.String,System.String,System.Int32)">
            <summary>
      Splits a subject string into a sequence of substrings that occur between the matches.
    </summary>
            <param name="subject">The subject string to be matched.</param><param name="pattern">The regular expression pattern.</param><param name="count">The maximum number of matches to attempt.</param>
            <remarks>
            <para>
      Note that using a static matching method is not efficient. For best performance,
      create a
      <see cref="T:PCRE.PcreRegex" />
      object and use its instance methods.
    </para>
            </remarks>
        </member>
        <member name="M:PCRE.PcreRegex.Split(System.String,System.String,PCRE.PcreOptions,PCRE.PcreSplitOptions)">
            <summary>
      Splits a subject string into a sequence of substrings that occur between the matches.
    </summary>
            <param name="subject">The subject string to be matched.</param><param name="pattern">The regular expression pattern.</param><param name="options">Additional options.</param><param name="splitOptions">Additional options for the split.</param>
            <remarks>
            <para>
      Note that using a static matching method is not efficient. For best performance,
      create a
      <see cref="T:PCRE.PcreRegex" />
      object and use its instance methods.
    </para>
            </remarks>
        </member>
        <member name="M:PCRE.PcreRegex.Split(System.String,System.String,PCRE.PcreOptions,PCRE.PcreSplitOptions,System.Int32)">
            <summary>
      Splits a subject string into a sequence of substrings that occur between the matches.
    </summary>
            <param name="subject">The subject string to be matched.</param><param name="pattern">The regular expression pattern.</param><param name="count">The maximum number of matches to attempt.</param><param name="options">Additional options.</param><param name="splitOptions">Additional options for the split.</param>
            <remarks>
            <para>
      Note that using a static matching method is not efficient. For best performance,
      create a
      <see cref="T:PCRE.PcreRegex" />
      object and use its instance methods.
    </para>
            </remarks>
        </member>
        <member name="M:PCRE.PcreRegex.Split(System.String,System.String,PCRE.PcreOptions,PCRE.PcreSplitOptions,System.Int32,System.Int32)">
            <summary>
      Splits a subject string into a sequence of substrings that occur between the matches.
    </summary>
            <param name="subject">The subject string to be matched.</param><param name="pattern">The regular expression pattern.</param><param name="count">The maximum number of matches to attempt.</param><param name="startIndex">The index at which the match should be attempted.</param><param name="options">Additional options.</param><param name="splitOptions">Additional options for the split.</param>
            <remarks>
            <para>
      Note that using a static matching method is not efficient. For best performance,
      create a
      <see cref="T:PCRE.PcreRegex" />
      object and use its instance methods.
    </para><para>
      Passing a non-zero
      <paramref name="startIndex" />
      differs from passing a shortened string if the pattern
      starts with an assertion (such as <c>\b</c>) or contains lookbehinds.
    </para>
            </remarks>
        </member>
        <member name="T:PCRE.PcreRegexSettings">
            <summary>
            Advanced regex settings.
            </summary>
        </member>
        <member name="P:PCRE.PcreRegexSettings.Options">
            <summary>
            The options to apply to the regex.
            </summary>
        </member>
        <member name="P:PCRE.PcreRegexSettings.NewLine">
            <summary>
            The character sequence that is recognized as meaning "newline".
            </summary>
        </member>
        <member name="P:PCRE.PcreRegexSettings.BackslashR">
            <summary>
            The character sequences the <c>\R</c> escape sequence matches.
            </summary>
        </member>
        <member name="P:PCRE.PcreRegexSettings.ParensLimit">
            <summary>
            The maximum depth of nesting of parentheses (of any kind).
            </summary>
        </member>
        <member name="P:PCRE.PcreRegexSettings.MaxPatternLength">
            <summary>
            The maximum length, in code units, for the pattern.
            </summary>
            <remarks>
            This facility is provided so that applications that accept patterns from external sources can limit their size.
            The default is the largest number that a <see cref="T:System.IntPtr"/> variable can hold, which is effectively unlimited.
            </remarks>
        </member>
        <member name="P:PCRE.PcreRegexSettings.MaxPatternCompiledLength">
            <summary>
            The maximum size, in bytes, for the memory needed to hold the compiled version of a pattern.
            </summary>
            <remarks>
            This facility is provided so that applications that accept patterns from external sources can limit the amount of memory they use.
            The default is the largest number that a <see cref="T:System.IntPtr"/> variable can hold, which is effectively unlimited.
            </remarks>
        </member>
        <member name="P:PCRE.PcreRegexSettings.MaxVarLookbehind">
            <summary>
            The maximum length for the number of characters matched by a variable-length lookbehind assertion.
            </summary>
            <remarks>
            The default is set when PCRE2 is built, with the ultimate default being 255, the same as Perl.
            Lookbehind assertions without a bounding length are not supported.
            </remarks>
        </member>
        <member name="P:PCRE.PcreRegexSettings.ExtraCompileOptions">
            <summary>
            Additional compile options.
            </summary>
        </member>
        <member name="P:PCRE.PcreRegexSettings.JitCompileOptions">
            <summary>
            Additional options for the JIT compiler.
            </summary>
        </member>
        <member name="M:PCRE.PcreRegexSettings.#ctor">
            <summary>
            Creates a new <see cref="T:PCRE.PcreRegexSettings"/> object.
            </summary>
        </member>
        <member name="T:PCRE.PcreSplitOptions">
            <summary>
            Options for string splitting.
            </summary>
        </member>
        <member name="F:PCRE.PcreSplitOptions.None">
            <summary>
            No additional options.
            </summary>
        </member>
        <member name="F:PCRE.PcreSplitOptions.IncludeGroupValues">
            <summary>
            Include captured groups as results of the split.
            </summary>
        </member>
    </members>
</doc>
